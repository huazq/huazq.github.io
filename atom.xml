<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>huazq&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huazq.github.io/"/>
  <updated>2020-03-31T08:36:29.662Z</updated>
  <id>https://huazq.github.io/</id>
  
  <author>
    <name>huazq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Qemu内存热插拔</title>
    <link href="https://huazq.github.io/2020/03/23/Qemu%E5%86%85%E5%AD%98%E7%83%AD%E6%8F%92%E6%8B%94/"/>
    <id>https://huazq.github.io/2020/03/23/Qemu内存热插拔/</id>
    <published>2020-03-23T02:29:00.000Z</published>
    <updated>2020-03-31T08:36:29.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存热插流程"><a href="#内存热插流程" class="headerlink" title="内存热插流程"></a>内存热插流程</h2><h3 id="1-qemu内存参数"><a href="#1-qemu内存参数" class="headerlink" title="1. qemu内存参数"></a>1. qemu内存参数</h3><p>qemu中内存参数列表(如下)中增加两个参数解析slots和maxmem,这两个分别代码了内存的槽和最大内存，而size就变成了当前内存。maxmem是内存的上限，而slots则代码可用于热插内存时需要的槽的上限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> QemuOptsList qemu_mem_opts = &#123;</span><br><span class="line">    .name = <span class="string">"memory"</span>,</span><br><span class="line">    .implied_opt_name = <span class="string">"size"</span>,</span><br><span class="line">    .head = QTAILQ_HEAD_INITIALIZER(qemu_mem_opts.head),</span><br><span class="line">    .merge_lists = <span class="literal">true</span>,</span><br><span class="line">    .desc = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            .name = <span class="string">"size"</span>,</span><br><span class="line">            .type = QEMU_OPT_SIZE,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .name = <span class="string">"slots"</span>,</span><br><span class="line">            .type = QEMU_OPT_NUMBER,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .name = <span class="string">"maxmem"</span>,</span><br><span class="line">            .type = QEMU_OPT_SIZE,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; <span class="comment">/* end of list */</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后在main函数中对memory命令行参数解析的时候,解析slot和maxmem参数,并设置到current_machine中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ram_addr_t</span> maxram_size = default_ram_size;</span><br><span class="line">    <span class="keyword">uint64_t</span> ram_slots = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">case</span> QEMU_OPTION_m: &#123;</span><br><span class="line">       <span class="keyword">uint64_t</span> sz;</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *mem_str;</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *maxmem_str, *slots_str;</span><br><span class="line">    ...</span><br><span class="line">       maxmem_str = qemu_opt_get(opts, <span class="string">"maxmem"</span>);</span><br><span class="line">       slots_str = qemu_opt_get(opts, <span class="string">"slots"</span>);</span><br><span class="line">       <span class="keyword">if</span> (maxmem_str &amp;&amp; slots_str) &#123;</span><br><span class="line">           <span class="keyword">uint64_t</span> slots;</span><br><span class="line"></span><br><span class="line">           sz = qemu_opt_get_size(opts, <span class="string">"maxmem"</span>, <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">if</span> (sz &lt; ram_size) &#123;</span><br><span class="line">               <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"qemu: invalid -m option value: maxmem "</span></span><br><span class="line">                       <span class="string">"(%"</span> PRIu64 <span class="string">") &lt;= initial memory (%"</span></span><br><span class="line">                       PRIu64 <span class="string">")\n"</span>, sz, ram_size);</span><br><span class="line">               <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           slots = qemu_opt_get_number(opts, <span class="string">"slots"</span>, <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">if</span> ((sz &gt; ram_size) &amp;&amp; !slots) &#123;</span><br><span class="line">               <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"qemu: invalid -m option value: maxmem "</span></span><br><span class="line">                       <span class="string">"(%"</span> PRIu64 <span class="string">") more than initial memory (%"</span></span><br><span class="line">                       PRIu64 <span class="string">") but no hotplug slots where "</span></span><br><span class="line">                       <span class="string">"specified\n"</span>, sz, ram_size);</span><br><span class="line">               <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ((sz &lt;= ram_size) &amp;&amp; slots) &#123;</span><br><span class="line">               <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"qemu: invalid -m option value:  %"</span></span><br><span class="line">                       PRIu64 <span class="string">" hotplug slots where specified but "</span></span><br><span class="line">                       <span class="string">"maxmem (%"</span> PRIu64 <span class="string">") &lt;= initial memory (%"</span></span><br><span class="line">                       PRIu64 <span class="string">")\n"</span>, slots, sz, ram_size);</span><br><span class="line">               <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line">           maxram_size = sz;</span><br><span class="line">           ram_slots = slots;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!maxmem_str &amp;&amp; slots_str) ||</span><br><span class="line">                  (maxmem_str &amp;&amp; !slots_str)) &#123;</span><br><span class="line">           <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"qemu: invalid -m option value: missing "</span></span><br><span class="line">                   <span class="string">"'%s' option\n"</span>, slots_str ? <span class="string">"maxmem"</span> : <span class="string">"slots"</span>);</span><br><span class="line">           <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">       &#125;</span><br><span class="line">...</span><br><span class="line">current_machine-&gt;maxram_size = maxram_size;</span><br><span class="line">current_machine-&gt;ram_slots = ram_slots;</span><br></pre></td></tr></table></figure><h3 id="2-热插内存接口"><a href="#2-热插内存接口" class="headerlink" title="2. 热插内存接口"></a>2. 热插内存接口</h3><ol><li>qemu热插内存时需要两步  <ul><li>“object_add”: creates a memory backend object  </li><li>“device_add”: creates a front-end pc-dimm device and inserts it into the first empty slot  </li></ul></li><li>举例  <ul><li>(qemu) object_add memory-backend-ram,id=mem1,size=1G  </li><li>(qemu) device_add pc-dimm,id=dimm1,memdev=mem1  </li></ul></li><li>object_add接口分析<br>object_add命令用于创建新的object，示例中创建的object是memory-backend-ram(参考hostmem-ram.c)，在monitor_init_qmp_commands中注册了object_add命令对应的执行函数qmp_object_add(如下)，qmp_object_add接口会先获取qom-type，在上面示例中为memory-bachend-ram，之后获取id(mem1)，然后获取属性(size=1G)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qmp_object_add</span><span class="params">(QDict *qdict, QObject **ret_data, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QObject *props;</span><br><span class="line">    QDict *pdict;</span><br><span class="line">    Visitor *v;</span><br><span class="line">    Object *obj;</span><br><span class="line">    g_autofree <span class="keyword">char</span> *type = <span class="literal">NULL</span>;</span><br><span class="line">    g_autofree <span class="keyword">char</span> *id = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*qom-type = memory-bachend-ram*/</span></span><br><span class="line">    type = g_strdup(qdict_get_try_str(qdict, <span class="string">"qom-type"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">        error_setg(errp, QERR_MISSING_PARAMETER, <span class="string">"qom-type"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    qdict_del(qdict, <span class="string">"qom-type"</span>);</span><br><span class="line"></span><br><span class="line">    id = g_strdup(qdict_get_try_str(qdict, <span class="string">"id"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">        error_setg(errp, QERR_MISSING_PARAMETER, <span class="string">"id"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    qdict_del(qdict, <span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line">    props = qdict_get(qdict, <span class="string">"props"</span>);</span><br><span class="line">    <span class="keyword">if</span> (props) &#123;</span><br><span class="line">        pdict = qobject_to(QDict, props);</span><br><span class="line">        <span class="keyword">if</span> (!pdict) &#123;</span><br><span class="line">            error_setg(errp, QERR_INVALID_PARAMETER_TYPE, <span class="string">"props"</span>, <span class="string">"dict"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qobject_ref(pdict);</span><br><span class="line">        qdict_del(qdict, <span class="string">"props"</span>);</span><br><span class="line">        qdict_join(qdict, pdict, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (qdict_size(pdict) != <span class="number">0</span>) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"Option in 'props' conflicts with top level"</span>);</span><br><span class="line">            qobject_unref(pdict);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qobject_unref(pdict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = qobject_input_visitor_new(QOBJECT(qdict));</span><br><span class="line">    obj = user_creatable_add_type(type, id, qdict, v, errp);</span><br><span class="line">    visit_free(v);</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        object_unref(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    *ret_data = QOBJECT(qdict_new());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>qobject_input_visitor_new用于封装属性参数，以便object对象设置属性的时候可以转换属性值的类型，user_creatable_add_type是真正创建对象的地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object *<span class="title">user_creatable_add_type</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QDict *qdict,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Visitor *v, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object *obj;</span><br><span class="line">    ObjectClass *klass;</span><br><span class="line">    <span class="keyword">const</span> QDictEntry *e;</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    klass = object_class_by_name(type);</span><br><span class="line">    <span class="keyword">if</span> (!klass) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"invalid object type: %s"</span>, type);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*type对应的TypeInfo必须具有值为TYPE_USER_CREATABLE的interfaces*/</span></span><br><span class="line">    <span class="keyword">if</span> (!object_class_dynamic_cast(klass, TYPE_USER_CREATABLE)) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"object type '%s' isn't supported by object-add"</span>,</span><br><span class="line">                   type);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object_class_is_abstract(klass)) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"object type '%s' is abstract"</span>, type);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(qdict);</span><br><span class="line">    <span class="comment">/*根据type创建object*/</span></span><br><span class="line">    obj = object_new(type);</span><br><span class="line">    visit_start_struct(v, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将object_add命令行中的props参数设置为object属性*/</span></span><br><span class="line">    <span class="keyword">for</span> (e = qdict_first(qdict); e; e = qdict_next(qdict, e)) &#123;</span><br><span class="line">        <span class="comment">/*这里object_property_set最终调用host_memory_backend_set_size*/</span></span><br><span class="line">        object_property_set(obj, v, e-&gt;key, &amp;local_err);</span><br><span class="line">        <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!local_err) &#123;</span><br><span class="line">        visit_check_struct(v, &amp;local_err);</span><br><span class="line">    &#125;</span><br><span class="line">    visit_end_struct(v, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/*将刚刚object_new出来的obj设置为root object的child属性里t*/</span></span><br><span class="line">        object_property_add_child(object_get_objects_root(),</span><br><span class="line">                                  id, obj, &amp;local_err);</span><br><span class="line">        <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*执行complete回调，memory-bachend-ram注册的complete回调函数为</span></span><br><span class="line"><span class="comment">    host_memory_backend_memory_complete函数*/</span></span><br><span class="line">    user_creatable_complete(USER_CREATABLE(obj), &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            object_property_del(object_get_objects_root(),</span><br><span class="line">                                id, &amp;error_abort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        error_propagate(errp, local_err);</span><br><span class="line">        object_unref(obj);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memory-bachend-ram的父object为memory-bachend，所以memory-bachend-ram继承了父object的UserCreatableClass，所以当上面user_creatable_complete中complete最终调用的是memory-bachend的class_init中注册的complete回调函数<strong>host_memory_backend_memory_complete</strong>，此函数负载内存申请以及为申请的内存创建numa策略:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">    HostMemoryBackend *backend = MEMORY_BACKEND(uc);</span><br><span class="line">    HostMemoryBackendClass *bc = MEMORY_BACKEND_GET_CLASS(uc);</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">uint64_t</span> sz;</span><br><span class="line">    <span class="comment">/*memory-backend-ram类型的class_init函数中将alloc回调函数被设置为</span></span><br><span class="line"><span class="comment">    ram_backend_memory_alloc函数，这个函数用于创建一个memory_region</span></span><br><span class="line"><span class="comment">    ,并为其申请backend-&gt;size(size就是通过host_memory_backend_set_size</span></span><br><span class="line"><span class="comment">    设置的)大小的内存*/</span></span><br><span class="line">    <span class="keyword">if</span> (bc-&gt;alloc) &#123;</span><br><span class="line">        bc-&gt;alloc(backend, &amp;local_err);</span><br><span class="line">        <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*获取内存起始地址*/</span></span><br><span class="line">        ptr = memory_region_get_ram_ptr(&amp;backend-&gt;mr);</span><br><span class="line">        <span class="comment">/*获取memory_region的size，这里是1G*/</span></span><br><span class="line">        sz = memory_region_size(&amp;backend-&gt;mr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (backend-&gt;merge) &#123;</span><br><span class="line">            qemu_madvise(ptr, sz, QEMU_MADV_MERGEABLE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!backend-&gt;dump) &#123;</span><br><span class="line">            qemu_madvise(ptr, sz, QEMU_MADV_DONTDUMP);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA <span class="comment">/*支持numa的话会根据numa策略决定mbind到哪些numa node上*/</span></span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> lastbit = find_last_bit(backend-&gt;host_nodes, MAX_NODES);</span><br><span class="line">        <span class="comment">/* lastbit == MAX_NODES means maxnode = 0 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> maxnode = (lastbit + <span class="number">1</span>) % (MAX_NODES + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* ensure policy won't be ignored in case memory is preallocated</span></span><br><span class="line"><span class="comment">         * before mbind(). note: MPOL_MF_STRICT is ignored on hugepages so</span></span><br><span class="line"><span class="comment">         * this doesn't catch hugepage case. */</span></span><br><span class="line">        <span class="keyword">unsigned</span> flags = MPOL_MF_STRICT | MPOL_MF_MOVE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check for invalid host-nodes and policies and give more verbose</span></span><br><span class="line"><span class="comment">         * error messages than mbind(). */</span></span><br><span class="line">        <span class="keyword">if</span> (maxnode &amp;&amp; backend-&gt;policy == MPOL_DEFAULT) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"host-nodes must be empty for policy default,"</span></span><br><span class="line">                       <span class="string">" or you should explicitly specify a policy other"</span></span><br><span class="line">                       <span class="string">" than default"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxnode == <span class="number">0</span> &amp;&amp; backend-&gt;policy != MPOL_DEFAULT) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"host-nodes must be set for policy %s"</span>,</span><br><span class="line">                       HostMemPolicy_str(backend-&gt;policy));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We can have up to MAX_NODES nodes, but we need to pass maxnode+1</span></span><br><span class="line"><span class="comment">         * as argument to mbind() due to an old Linux bug (feature?) which</span></span><br><span class="line"><span class="comment">         * cuts off the last specified node. This means backend-&gt;host_nodes</span></span><br><span class="line"><span class="comment">         * must have MAX_NODES+1 bits available.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(<span class="keyword">sizeof</span>(backend-&gt;host_nodes) &gt;=</span><br><span class="line">               BITS_TO_LONGS(MAX_NODES + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>));</span><br><span class="line">        assert(maxnode &lt;= MAX_NODES);</span><br><span class="line">        <span class="keyword">if</span> (mbind(ptr, sz, backend-&gt;policy,</span><br><span class="line">                  maxnode ? backend-&gt;host_nodes : <span class="literal">NULL</span>, maxnode + <span class="number">1</span>, flags)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (backend-&gt;policy != MPOL_DEFAULT || errno != ENOSYS) &#123;</span><br><span class="line">                error_setg_errno(errp, errno,</span><br><span class="line">                                 <span class="string">"cannot bind memory to host NUMA nodes"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* Preallocate memory after the NUMA policy has been instantiated.</span></span><br><span class="line"><span class="comment">         * This is necessary to guarantee memory is allocated with</span></span><br><span class="line"><span class="comment">         * specified NUMA policy in place.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*根据object-add命令行是否传入prealloc=on|off属性决定</span></span><br><span class="line"><span class="comment">        是否启用预分配内存*/</span></span><br><span class="line">        <span class="keyword">if</span> (backend-&gt;prealloc) &#123;</span><br><span class="line">            <span class="comment">/*os_mem_prealloc的实现很简单，就是启动多个线程</span></span><br><span class="line"><span class="comment">            (线程数量根据cpu数量决定)访问刚刚申请的内存地址，</span></span><br><span class="line"><span class="comment">            触发pagefault分配物理内存*/</span></span><br><span class="line">            os_mem_prealloc(memory_region_get_fd(&amp;backend-&gt;mr), ptr, sz,</span><br><span class="line">                            backend-&gt;prealloc_threads, &amp;local_err);</span><br><span class="line">            <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    error_propagate(errp, local_err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>device_add接口分析<br>device_add命令是热插设备的接口，内存热插时指定设备类型为pc-dimm即为热插一个内存条，热插设备调用的接口是qmp_device_add：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qmp_device_add</span><span class="params">(QDict *qdict, QObject **ret_data, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line">    QemuOpts *opts;</span><br><span class="line">    DeviceState *dev;</span><br><span class="line"></span><br><span class="line">    opts = qemu_opts_from_qdict(qemu_find_opts(<span class="string">"device"</span>), qdict, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        error_propagate(errp, local_err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!monitor_cur_is_qmp() &amp;&amp; qdev_device_help(opts)) &#123;</span><br><span class="line">        qemu_opts_del(opts);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*调用qdev_device_add热插设备*/</span></span><br><span class="line">    dev = qdev_device_add(opts, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">        error_propagate(errp, local_err);</span><br><span class="line">        qemu_opts_del(opts);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    object_unref(OBJECT(dev));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>qdev_device_add是执行创建设备的函数:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DeviceState *<span class="title">qdev_device_add</span><span class="params">(QemuOpts *opts, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DeviceClass *dc;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *driver, *path;</span><br><span class="line">    DeviceState *dev = <span class="literal">NULL</span>;</span><br><span class="line">    BusState *bus = <span class="literal">NULL</span>;</span><br><span class="line">    Error *err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">bool</span> hide;</span><br><span class="line">    <span class="comment">/*查找设备driver*/</span></span><br><span class="line">    driver = qemu_opt_get(opts, <span class="string">"driver"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!driver) &#123;</span><br><span class="line">        error_setg(errp, QERR_MISSING_PARAMETER, <span class="string">"driver"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find driver */</span></span><br><span class="line">    dc = qdev_get_device_class(&amp;driver, errp);</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find bus */</span></span><br><span class="line">    path = qemu_opt_get(opts, <span class="string">"bus"</span>);</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find(path, errp);</span><br><span class="line">        <span class="keyword">if</span> (!bus) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!object_dynamic_cast(OBJECT(bus), dc-&gt;bus_type)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"Device '%s' can't go on %s bus"</span>,</span><br><span class="line">                       driver, object_get_typename(OBJECT(bus)));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dc-&gt;bus_type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find_recursive(sysbus_get_default(), <span class="literal">NULL</span>, dc-&gt;bus_type);</span><br><span class="line">        <span class="keyword">if</span> (!bus || qbus_is_full(bus)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"No '%s' bus found for device '%s'"</span>,</span><br><span class="line">                       dc-&gt;bus_type, driver);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hide = should_hide_device(opts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((hide || qdev_hotplug) &amp;&amp; bus &amp;&amp; !qbus_is_hotpluggable(bus)) &#123;</span><br><span class="line">        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hide) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!migration_is_idle()) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"device_add not allowed while migrating"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create pc-dimm device */</span></span><br><span class="line">    dev = DEVICE(object_new(driver));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check whether the hotplug is allowed by the machine */</span></span><br><span class="line">    <span class="keyword">if</span> (qdev_hotplug &amp;&amp; !qdev_hotplug_allowed(dev, &amp;err)) &#123;</span><br><span class="line">        <span class="comment">/* Error must be set in the machine hook */</span></span><br><span class="line">        assert(err);</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus) &#123;</span><br><span class="line">        qdev_set_parent_bus(dev, bus);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qdev_hotplug &amp;&amp; !qdev_get_machine_hotplug_handler(dev)) &#123;</span><br><span class="line">        <span class="comment">/* No bus, no machine hotplug handler --&gt; device is not hotpluggable */</span></span><br><span class="line">        error_setg(&amp;err, <span class="string">"Device '%s' can not be hotplugged on this machine"</span>,</span><br><span class="line">                   driver);</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*设置id为dimm1*/</span></span><br><span class="line">    qdev_set_id(dev, qemu_opts_id(opts));</span><br><span class="line">    <span class="comment">/* pc-dimm设备配置了link属性memdev，memdev属性是将通过将命令行</span></span><br><span class="line"><span class="comment">    中memdev对应的object转换为HostMemoryBackend类型的object，并赋值给</span></span><br><span class="line"><span class="comment">    PCDIMMDevice-&gt;hostmem，这里通过set_property(最终调用 object_set_link_property)将HostMemoryBackend指针指向为名为mem1的object */</span></span><br><span class="line">    <span class="keyword">if</span> (qemu_opt_foreach(opts, set_property, dev, &amp;err)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;opts = opts;</span><br><span class="line">    <span class="comment">/*将Device的realized属性设为true，触发调用device_set_realized*/</span></span><br><span class="line">    object_property_set_bool(OBJECT(dev), <span class="literal">true</span>, <span class="string">"realized"</span>, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev-&gt;opts = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line">err_del_dev:</span><br><span class="line">    error_propagate(errp, err);</span><br><span class="line">    <span class="keyword">if</span> (dev) &#123;</span><br><span class="line">        object_unparent(OBJECT(dev));</span><br><span class="line">        object_unref(OBJECT(dev));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>device_set_realized是真正进行内存热插拔的函数：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value &amp;&amp; !dev-&gt;realized) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!check_only_migratable(obj, &amp;local_err)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!obj-&gt;parent) &#123;</span><br><span class="line">        gchar *name = g_strdup_printf(<span class="string">"device[%d]"</span>, unattached_count++);</span><br><span class="line"></span><br><span class="line">        object_property_add_child(container_get(qdev_get_machine(),</span><br><span class="line">                                                <span class="string">"/unattached"</span>),</span><br><span class="line">                                  name, obj, &amp;error_abort);</span><br><span class="line">        unattached_parent = <span class="literal">true</span>;</span><br><span class="line">        g_free(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这里调用qdev_get_hotplug_handler回调得到HotplugHandler指针，以pc机器为例，mc-&gt;get_hotplug_handler回调函数设置为pc_get_hotplug_handler，调用</span></span><br><span class="line"><span class="comment">    pc_get_hotplug_handler返回TYPE_HOTPLUG_HANDLER类型的object*/</span></span><br><span class="line">    hotplug_ctrl = qdev_get_hotplug_handler(dev);</span><br><span class="line">    <span class="keyword">if</span> (hotplug_ctrl) &#123;</span><br><span class="line">        <span class="comment">/*调用pc_dimm_pre_plug分配slot并设置到pc-dimm设备的slot属性</span></span><br><span class="line"><span class="comment">        上，同时调用get_memory_region获取mem1对应的内存地址，并设置</span></span><br><span class="line"><span class="comment">        到pc-dimm设备的addr属性上*/</span></span><br><span class="line">        hotplug_handler_pre_plug(hotplug_ctrl, dev, &amp;local_err);</span><br><span class="line">        <span class="keyword">if</span> (local_err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dc-&gt;realize) &#123;</span><br><span class="line">        <span class="comment">/*调用pc_dimm_realize*/</span></span><br><span class="line">        dc-&gt;realize(dev, &amp;local_err);</span><br><span class="line">        <span class="keyword">if</span> (local_err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DEVICE_LISTENER_CALL(realize, Forward, dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * always free/re-initialize here since the value cannot be cleaned up</span></span><br><span class="line"><span class="comment">     * in device_unrealize due to its usage later on in the unplug path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    g_free(dev-&gt;canonical_path);</span><br><span class="line">    dev-&gt;canonical_path = object_get_canonical_path(OBJECT(dev));</span><br><span class="line">    <span class="comment">/*将设备注册到vmstate上*/</span></span><br><span class="line">    <span class="keyword">if</span> (qdev_get_vmsd(dev)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmstate_register_with_alias_id(VMSTATE_IF(dev),</span><br><span class="line">                                           VMSTATE_INSTANCE_ID_ANY,</span><br><span class="line">                                           qdev_get_vmsd(dev), dev,</span><br><span class="line">                                           dev-&gt;instance_id_alias,</span><br><span class="line">                                           dev-&gt;alias_required_for_version,</span><br><span class="line">                                           &amp;local_err) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> post_realize_fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Clear the reset state, in case the object was previously unrealized</span></span><br><span class="line"><span class="comment">     * with a dirty state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    resettable_state_clear(&amp;dev-&gt;reset);</span><br><span class="line"></span><br><span class="line">    QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) &#123;</span><br><span class="line">        object_property_set_bool(OBJECT(bus), <span class="literal">true</span>, <span class="string">"realized"</span>,</span><br><span class="line">                                     &amp;local_err);</span><br><span class="line">        <span class="keyword">if</span> (local_err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> child_realize_fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;hotplugged) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Reset the device, as well as its subtree which, at this point,</span></span><br><span class="line"><span class="comment">         * should be realized too.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        resettable_assert_reset(OBJECT(dev), RESET_TYPE_COLD);</span><br><span class="line">        resettable_change_parent(OBJECT(dev), OBJECT(dev-&gt;parent_bus),</span><br><span class="line">                                 <span class="literal">NULL</span>);</span><br><span class="line">        resettable_release_reset(OBJECT(dev), RESET_TYPE_COLD);</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;pending_deleted_event = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hotplug_ctrl) &#123;</span><br><span class="line">        <span class="comment">/*调用pc-dimm-plug热插内存*/</span></span><br><span class="line">        hotplug_handler_plug(hotplug_ctrl, dev, &amp;local_err);</span><br><span class="line">        <span class="keyword">if</span> (local_err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> child_realize_fail;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存热插流程&quot;&gt;&lt;a href=&quot;#内存热插流程&quot; class=&quot;headerlink&quot; title=&quot;内存热插流程&quot;&gt;&lt;/a&gt;内存热插流程&lt;/h2&gt;&lt;h3 id=&quot;1-qemu内存参数&quot;&gt;&lt;a href=&quot;#1-qemu内存参数&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="qemu" scheme="https://huazq.github.io/categories/qemu/"/>
    
    
  </entry>
  
  <entry>
    <title>Qemu中VNC Server分析</title>
    <link href="https://huazq.github.io/2020/01/18/Qemu%E4%B8%ADVNC-Server%E5%88%86%E6%9E%90/"/>
    <id>https://huazq.github.io/2020/01/18/Qemu中VNC-Server分析/</id>
    <published>2020-01-18T07:55:00.000Z</published>
    <updated>2020-02-11T06:27:18.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VNC介绍"><a href="#VNC介绍" class="headerlink" title="VNC介绍"></a>VNC介绍</h2><p>vnc是一个桌面传输协议，使用的是RFB协议格式，RFB协议是一个基于TCP的应用层传输协议。基于vnc协议实现的程序有很多，最出名的两个就是大家所熟悉的TightVNC和RealVNC。同样，Qemu模拟器中也实现了vnc(qemu中的vnc为Server端)，qemu中的vnc是为了用于展示虚拟机的界面，方便用户和虚拟机交互，今天就来分析下Qemu中的vnc实现。</p><h2 id="Qemu中VNC参数"><a href="#Qemu中VNC参数" class="headerlink" title="Qemu中VNC参数"></a>Qemu中VNC参数</h2><p>Qemu是在vl.c的main函数中通过QEMU_OPTION_vnc选项对vnc命令行参数进行解析，vnc的参数格式定义在vnc.c文件中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> QemuOptsList qemu_vnc_opts = &#123;</span><br><span class="line">    .name = <span class="string">"vnc"</span>,</span><br><span class="line">    .head = QTAILQ_HEAD_INITIALIZER(qemu_vnc_opts.head),</span><br><span class="line">    .implied_opt_name = <span class="string">"vnc"</span>,</span><br><span class="line">    .desc = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            .name = <span class="string">"vnc"</span>,</span><br><span class="line">            .type = QEMU_OPT_STRING,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"websocket"</span>,</span><br><span class="line">            .type = QEMU_OPT_STRING,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"tls-creds"</span>,</span><br><span class="line">            .type = QEMU_OPT_STRING,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"share"</span>,</span><br><span class="line">            .type = QEMU_OPT_STRING,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"display"</span>,</span><br><span class="line">            .type = QEMU_OPT_STRING,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"head"</span>,</span><br><span class="line">            .type = QEMU_OPT_NUMBER,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"connections"</span>,</span><br><span class="line">            .type = QEMU_OPT_NUMBER,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"to"</span>,</span><br><span class="line">            .type = QEMU_OPT_NUMBER,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"ipv4"</span>,</span><br><span class="line">            .type = QEMU_OPT_BOOL,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"ipv6"</span>,</span><br><span class="line">            .type = QEMU_OPT_BOOL,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"password"</span>,</span><br><span class="line">            .type = QEMU_OPT_BOOL,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"reverse"</span>,</span><br><span class="line">            .type = QEMU_OPT_BOOL,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"lock-key-sync"</span>,</span><br><span class="line">            .type = QEMU_OPT_BOOL,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"key-delay-ms"</span>,</span><br><span class="line">            .type = QEMU_OPT_NUMBER,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"sasl"</span>,</span><br><span class="line">            .type = QEMU_OPT_BOOL,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"acl"</span>,</span><br><span class="line">            .type = QEMU_OPT_BOOL,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"tls-authz"</span>,</span><br><span class="line">            .type = QEMU_OPT_STRING,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"sasl-authz"</span>,</span><br><span class="line">            .type = QEMU_OPT_STRING,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"lossy"</span>,</span><br><span class="line">            .type = QEMU_OPT_BOOL,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            .name = <span class="string">"non-adaptive"</span>,</span><br><span class="line">            .type = QEMU_OPT_BOOL,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; <span class="comment">/* end of list */</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="上述参数含义"><a href="#上述参数含义" class="headerlink" title="上述参数含义"></a>上述参数含义</h3><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>vnc</td><td>vnc地址</td></tr><tr><td>websocket</td><td>是否使用websocket协议</td></tr><tr><td>tls-creds</td><td>tls证书</td></tr><tr><td>share</td><td>vnc协议的共享策略(忽略、排他、强制共享三种策略)</td></tr><tr><td>display</td><td>展示哪个串口设备</td></tr><tr><td>head</td><td>和display一起使用，用于判断串口设备</td></tr><tr><td>connections</td><td>vnc连接数限制，默认32</td></tr><tr><td>to</td><td>是否使用websocket协议</td></tr><tr><td>ipv4</td><td>vnc地址使用ipv4格式</td></tr><tr><td>ipv6</td><td>vnc地址使用ipv6格式</td></tr><tr><td>password</td><td>vnc密码</td></tr><tr><td>reverse</td><td></td></tr><tr><td>lock-key-sync</td><td>numlock以及capslock键状态同步</td></tr><tr><td>key-delay-ms</td><td>键盘输入延迟时间(单位:毫秒)</td></tr><tr><td>sasl</td><td>是否开启sasl认证</td></tr><tr><td>acl</td><td>不再使用</td></tr><tr><td>tls-authz</td><td>vnc使用tls认证</td></tr><tr><td>sasl-authz</td><td>vnc使用sasl认证</td></tr><tr><td>lossy</td><td>如果启用lossy，则禁用adaptive updates,即低质量画面传输</td></tr><tr><td>non-adaptive</td><td>是否使用高质量画面传输(禁用压缩)</td></tr><tr><td>## VNC主要数据结构</td><td></td></tr><tr><td><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VncDisplay</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QTAILQ_HEAD(, VncState) clients;</span><br><span class="line">    <span class="keyword">int</span> num_connecting;</span><br><span class="line">    <span class="keyword">int</span> num_shared;</span><br><span class="line">    <span class="keyword">int</span> num_exclusive;</span><br><span class="line">    <span class="keyword">int</span> connections_limit;</span><br><span class="line">    VncSharePolicy share_policy;</span><br><span class="line">    QIONetListener *listener;</span><br><span class="line">    QIONetListener *wslistener;</span><br><span class="line">    DisplaySurface *ds;</span><br><span class="line">    DisplayChangeListener dcl;</span><br><span class="line">    <span class="keyword">kbd_layout_t</span> *kbd_layout;</span><br><span class="line">    <span class="keyword">int</span> lock_key_sync;</span><br><span class="line">    QEMUPutLEDEntry *led;</span><br><span class="line">    <span class="keyword">int</span> ledstate;</span><br><span class="line">    QKbdState *kbd;</span><br><span class="line">    QemuMutex mutex;</span><br><span class="line"></span><br><span class="line">    QEMUCursor *cursor;</span><br><span class="line">    <span class="keyword">int</span> cursor_msize;</span><br><span class="line">    <span class="keyword">uint8_t</span> *cursor_mask;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VncSurface</span> <span class="title">guest</span>;</span>   <span class="comment">/* guest visible surface (aka ds-&gt;surface) */</span></span><br><span class="line">    <span class="keyword">pixman_image_t</span> *server;    <span class="comment">/* vnc server surface */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;</span><br><span class="line">    QTAILQ_ENTRY(VncDisplay) next;</span><br><span class="line">    <span class="keyword">bool</span> is_unix;</span><br><span class="line">    <span class="keyword">char</span> *password;</span><br><span class="line">    <span class="keyword">time_t</span> expires;</span><br><span class="line">    <span class="keyword">int</span> auth;</span><br><span class="line">    <span class="keyword">int</span> subauth; <span class="comment">/* Used by VeNCrypt */</span></span><br><span class="line">    <span class="keyword">int</span> ws_auth; <span class="comment">/* Used by websockets */</span></span><br><span class="line">    <span class="keyword">int</span> ws_subauth; <span class="comment">/* Used by websockets */</span></span><br><span class="line">    <span class="keyword">bool</span> lossy;</span><br><span class="line">    <span class="keyword">bool</span> non_adaptive;</span><br><span class="line">    QCryptoTLSCreds *tlscreds;</span><br><span class="line">    QAuthZ *tlsauthz;</span><br><span class="line">    <span class="keyword">char</span> *tlsauthzid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VNC_SASL</span></span><br><span class="line">    VncDisplaySASL sasl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></td><td></td></tr></tbody></table><p><strong>VncDisplay</strong>:代表一个VNC Server的结构体，在qemu解析参数并初始化vnc的时候会调用到vnc_display_init，在这里会分配一个VncDisplay实例，并加入到全局链表vnc_displays(如果配置了多个vnc,则全局链表中有多个VncDisplay实例，即代表qemu有多个VNC Server)，可以看到VncDisplay结构体中的大部分参数和我们之前讲的qemu命令行中vnc参数是一致的，这里不再对VncDisplay结构体的参数详细阐述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VncState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> magic;   <span class="comment">/* 0x05b3f069b3d204bb */</span></span><br><span class="line">    QIOChannelSocket *sioc; <span class="comment">/* The underlying socket，socket wrapper */</span></span><br><span class="line">    QIOChannel *ioc; <span class="comment">/* The channel currently used for I/O */</span></span><br><span class="line">    guint ioc_tag;</span><br><span class="line">    gboolean disconnecting;</span><br><span class="line"></span><br><span class="line">    DECLARE_BITMAP(dirty[VNC_MAX_HEIGHT], VNC_DIRTY_BITS);</span><br><span class="line">    <span class="keyword">uint8_t</span> **lossy_rect; <span class="comment">/* Not an Array to avoid costly memcpy in</span></span><br><span class="line"><span class="comment">                           * vnc-jobs-async.c */</span></span><br><span class="line"></span><br><span class="line">    VncDisplay *vd; <span class="comment">/*vnc server connect to*/</span></span><br><span class="line">    VncStateUpdate update; <span class="comment">/* Most recent pending request from client */</span></span><br><span class="line">    VncStateUpdate job_update; <span class="comment">/* Currently processed by job thread */</span></span><br><span class="line">    <span class="keyword">int</span> has_dirty;</span><br><span class="line">    <span class="keyword">uint32_t</span> features;</span><br><span class="line">    <span class="keyword">int</span> absolute;</span><br><span class="line">    <span class="keyword">int</span> last_x;</span><br><span class="line">    <span class="keyword">int</span> last_y;</span><br><span class="line">    <span class="keyword">uint32_t</span> last_bmask;</span><br><span class="line">    <span class="keyword">size_t</span> client_width; <span class="comment">/* limited to u16 by RFB proto */</span></span><br><span class="line">    <span class="keyword">size_t</span> client_height; <span class="comment">/* limited to u16 by RFB proto */</span></span><br><span class="line">    VncShareMode share_mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> vnc_encoding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> auth;</span><br><span class="line">    <span class="keyword">int</span> subauth; <span class="comment">/* Used by VeNCrypt */</span></span><br><span class="line">    <span class="keyword">char</span> challenge[VNC_AUTH_CHALLENGE_SIZE];</span><br><span class="line">    QCryptoTLSSession *tls; <span class="comment">/* Borrowed pointer from channel, don't free */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VNC_SASL</span></span><br><span class="line">    VncStateSASL sasl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">bool</span> encode_ws;</span><br><span class="line">    <span class="keyword">bool</span> websocket;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VNC</span></span><br><span class="line">    VncClientInfo *info;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Job thread bottom half has put data for a forced update</span></span><br><span class="line"><span class="comment">     * into the output buffer. This offset points to the end of</span></span><br><span class="line"><span class="comment">     * the update data in the output buffer. This lets us determine</span></span><br><span class="line"><span class="comment">     * when a force update is fully sent to the client, allowing</span></span><br><span class="line"><span class="comment">     * us to process further forced updates. */</span></span><br><span class="line">    <span class="keyword">size_t</span> force_update_offset;</span><br><span class="line">    <span class="comment">/* We allow multiple incremental updates or audio capture</span></span><br><span class="line"><span class="comment">     * samples to be queued in output buffer, provided the</span></span><br><span class="line"><span class="comment">     * buffer size doesn't exceed this threshold. The value</span></span><br><span class="line"><span class="comment">     * is calculating dynamically based on framebuffer size</span></span><br><span class="line"><span class="comment">     * and audio sample settings in vnc_update_throttle_offset() */</span></span><br><span class="line">    <span class="keyword">size_t</span> throttle_output_offset;</span><br><span class="line">    Buffer output;</span><br><span class="line">    Buffer input;</span><br><span class="line">    <span class="comment">/* current output mode information */</span></span><br><span class="line">    VncWritePixels *write_pixels;</span><br><span class="line">    PixelFormat client_pf;</span><br><span class="line">    <span class="keyword">pixman_format_code_t</span> client_format;</span><br><span class="line">    <span class="keyword">bool</span> client_be;</span><br><span class="line"></span><br><span class="line">    CaptureVoiceOut *audio_cap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">audsettings</span> <span class="title">as</span>;</span></span><br><span class="line"></span><br><span class="line">    VncReadEvent *read_handler;</span><br><span class="line">    <span class="keyword">size_t</span> read_handler_expect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">abort</span>;</span><br><span class="line">    QemuMutex output_mutex;</span><br><span class="line">    QEMUBH *bh;</span><br><span class="line">    Buffer jobs_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Encoding specific, if you add something here, don't forget to</span></span><br><span class="line"><span class="comment">     *  update vnc_async_encoding_start()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    VncTight tight;</span><br><span class="line">    VncZlib zlib;</span><br><span class="line">    VncHextile hextile;</span><br><span class="line">    VncZrle zrle;</span><br><span class="line">    VncZywrle zywrle;</span><br><span class="line"></span><br><span class="line">    Notifier mouse_mode_notifier;</span><br><span class="line"></span><br><span class="line">    QTAILQ_ENTRY(VncState) next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>VncState</strong>:表示VNC Client的状态信息，在VncDisplay有个client链表(QTAILQ_HEAD(, VncState) clients;)，即每个VNC Server(VncDisplay)可能会有多个client连接(默认最高32个client),每个client都会有一些状态信息(包括client channel, dirty bitmap，宽高，共享模式，auth方式，连接方式(ws or tcp ),音频采集以及数据压缩方式等等)，VncState就是用来报存这些状态信息的.</p><p><strong>VncState中包含的几种VNC编码方式</strong>：<br></p><ul><li><strong><em>VncTight</em></strong>：即Tight Encoding，包含四种压缩类型:fill, jpeg, png, basic。Tight Encoding是一种自适应的轻量级编码方式，会根据传输数据动态决定使用哪种压缩方式。<br></li><li><strong><em>VncZlib</em></strong>：zlib压缩，即vnc数据传输使用标准的zlib压缩。<br></li><li><strong><em>VncHextile</em></strong>：Hextile编码是RRE编码(RRE是将象素颜色相同的某一个矩形区域作为一个整体传输)的变种，把屏幕分成16x16象素的小块，每块用Raw或RRE方式转送，详细可以参考<a href="https://tools.ietf.org/html/rfc6143" target="_blank" rel="noopener">RFB协议</a>。<br></li><li><strong><em>VncZrle</em></strong>：zrle编码就是zlib的游标编码(run-length encoding)，详细可以参考<a href="https://tools.ietf.org/html/rfc6143" target="_blank" rel="noopener">RFB协议</a><br></li><li><strong><em>VncZywrle</em></strong>：zywrle表示ZLib YUV Wavelet Run Length Encoding，zywrle编码是为了提高VNC codec for Motion picture，即可以以更高质量的压缩数据，具体可参考<a href="https://forum.ultravnc.net/viewtopic.php?t=9167" target="_blank" rel="noopener">zywrle说明</a><br></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VncRect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VncRectEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VncRect</span> <span class="title">rect</span>;</span></span><br><span class="line">    QLIST_ENTRY(VncRectEntry) next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VncJob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VncState *vs;</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, VncRectEntry) rectangles;</span><br><span class="line">    QTAILQ_ENTRY(VncJob) next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VncJobQueue</span> &#123;</span></span><br><span class="line">    QemuCond cond;</span><br><span class="line">    QemuMutex mutex;</span><br><span class="line">    QemuThread thread;</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">exit</span>;</span><br><span class="line">    QTAILQ_HEAD(, VncJob) jobs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>VncRect</strong>:表示VNC 变化的区域信息，包含了变化区域坐上面坐标(x,y)，以及变化区域的宽w,高h<br><br><strong>VncRectEntry</strong>:将所有VNC 变化区域信息组成链表放在VncRectEntry结构中<br><br><strong>VncJob</strong>:表示一个更新的job，每个job包含当时所有的变化区域信息<br><br><strong>VncJobQueue</strong>:表示job队列，以及处理job的线程信息<br></p><h2 id="VNC初始化流程分析"><a href="#VNC初始化流程分析" class="headerlink" title="VNC初始化流程分析"></a>VNC初始化流程分析</h2><p>在vl.c中的main函数会解析vnc参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> QEMU_OPTION_vnc:</span><br><span class="line">   vnc_parse(optarg, &amp;error_fatal);</span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>之后在解析完参数后会调用vnc_init_func初始化vnc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* init remote displays */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VNC</span></span><br><span class="line">    qemu_opts_foreach(qemu_find_opts(<span class="string">"vnc"</span>), </span><br><span class="line">                  vnc_init_func, <span class="literal">NULL</span>,  &amp;error_fatal);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>vnc的实现主要在ui/vnc.c文件中(vnc的各种数据压缩方式的实现在其他文件)。 初始化入口是vnc_init_func函数，vnc_init_func函数中会调用vnc_display_init初始化VncDisplay，之后调用vnc_display_open监听客户端连接，vnc_init_func实现如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vnc_init_func</span><span class="params">(<span class="keyword">void</span> *opaque, QemuOpts *opts, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *id = (<span class="keyword">char</span> *)qemu_opts_id(opts);</span><br><span class="line"></span><br><span class="line">    assert(id);</span><br><span class="line">    vnc_display_init(id, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        error_propagate(errp, local_err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vnc_display_open(id, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_propagate(errp, local_err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数vnc_display_init主要是初始化对应的VncDisplay以及启动worker线程处理vnc数据更新队列,以及注册对应的dcl_ops(监听显示设备变化的操作集):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vnc_display_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VncDisplay *vd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnc_display_find(id) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vd = g_malloc0(<span class="keyword">sizeof</span>(*vd));</span><br><span class="line"></span><br><span class="line">    vd-&gt;id = strdup(id);</span><br><span class="line">    QTAILQ_INSERT_TAIL(&amp;vnc_displays, vd, next);</span><br><span class="line"></span><br><span class="line">    QTAILQ_INIT(&amp;vd-&gt;clients);</span><br><span class="line">    vd-&gt;expires = TIME_MAX;</span><br><span class="line">    <span class="comment">/*默认是英文键盘*/</span></span><br><span class="line">    <span class="keyword">if</span> (keyboard_layout) &#123;</span><br><span class="line">        trace_vnc_key_map_init(keyboard_layout);</span><br><span class="line">        vd-&gt;kbd_layout = init_keyboard_layout(name2keysym,</span><br><span class="line">                                              keyboard_layout, errp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vd-&gt;kbd_layout = init_keyboard_layout(name2keysym, <span class="string">"en-us"</span>, errp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vd-&gt;kbd_layout) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vd-&gt;share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;<span class="comment">/*默认独享*/</span></span><br><span class="line">    vd-&gt;connections_limit = <span class="number">32</span>; <span class="comment">/*默认连接数为32*/</span></span><br><span class="line"></span><br><span class="line">    qemu_mutex_init(&amp;vd-&gt;mutex);</span><br><span class="line">    <span class="comment">/*启动工作线程处理framebuffer更新*/</span></span><br><span class="line">    vnc_start_worker_thread();</span><br><span class="line"></span><br><span class="line">    vd-&gt;dcl.ops = &amp;dcl_ops;</span><br><span class="line">    register_displaychangelistener(&amp;vd-&gt;dcl);</span><br><span class="line">    vd-&gt;kbd = qkbd_state_init(vd-&gt;dcl.con);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisplayChangeListenerOps表示当显示设备发生改变时所触发的操作，dcl_ops定义了vnc对显示设备变化时的相关操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> DisplayChangeListenerOps dcl_ops = &#123;</span><br><span class="line">    .dpy_name             = <span class="string">"vnc"</span>,</span><br><span class="line">    .dpy_refresh          = vnc_refresh,</span><br><span class="line">    .dpy_gfx_update       = vnc_dpy_update,</span><br><span class="line">    .dpy_gfx_switch       = vnc_dpy_switch,</span><br><span class="line">    .dpy_gfx_check_format = qemu_pixman_check_format,</span><br><span class="line">    .dpy_mouse_set        = vnc_mouse_set,</span><br><span class="line">    .dpy_cursor_define    = vnc_dpy_cursor_define,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>register_displaychangelistener负责设置刷新定时器(调用dpy_refresh),更新console等:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_displaychangelistener</span><span class="params">(DisplayChangeListener *dcl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> nodev[] =</span><br><span class="line">        <span class="string">"This VM has no graphic display device."</span>;</span><br><span class="line">    <span class="keyword">static</span> DisplaySurface *dummy;</span><br><span class="line">    QemuConsole *con;</span><br><span class="line"></span><br><span class="line">    assert(!dcl-&gt;ds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dcl-&gt;ops-&gt;dpy_gl_ctx_create) &#123;</span><br><span class="line">        <span class="comment">/* display has opengl support */</span></span><br><span class="line">        assert(dcl-&gt;con);</span><br><span class="line">        <span class="keyword">if</span> (dcl-&gt;con-&gt;gl) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't register two opengl displays (%s, %s)\n"</span>,</span><br><span class="line">                    dcl-&gt;ops-&gt;dpy_name, dcl-&gt;con-&gt;gl-&gt;ops-&gt;dpy_name);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dcl-&gt;con-&gt;gl = dcl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_displaychangelistener_register(dcl, dcl-&gt;ops-&gt;dpy_name);</span><br><span class="line">    dcl-&gt;ds = get_alloc_displaystate();</span><br><span class="line">    <span class="comment">/*将注册的dcl插入到listeners链表*/</span></span><br><span class="line">    QLIST_INSERT_HEAD(&amp;dcl-&gt;ds-&gt;listeners, dcl, next);</span><br><span class="line">    <span class="comment">/*设置refresh定时器，定时器调用的是dpy_refresh指针(指向的vnc_refresh)*/</span></span><br><span class="line">    gui_setup_refresh(dcl-&gt;ds);</span><br><span class="line">    <span class="keyword">if</span> (dcl-&gt;con) &#123;</span><br><span class="line">        dcl-&gt;con-&gt;dcls++;</span><br><span class="line">        con = dcl-&gt;con;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        con = active_console;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dcl-&gt;ops-&gt;dpy_gfx_switch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (con) &#123;</span><br><span class="line">            dcl-&gt;ops-&gt;dpy_gfx_switch(dcl, con-&gt;surface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dummy) &#123;</span><br><span class="line">                dummy = qemu_create_message_surface(<span class="number">640</span>, <span class="number">480</span>, nodev);</span><br><span class="line">            &#125;</span><br><span class="line">            dcl-&gt;ops-&gt;dpy_gfx_switch(dcl, dummy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    text_console_update_cursor(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_display_open中主要对qemu命令行传入的参数校验，之后会根据入参设置vnc监听地址、vnc密码、连接方式，共享方式、认证模式、连接数、压缩方式等，最后开始监听socket等待客户端连接：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vnc_display_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VncDisplay *vd = vnc_display_find(id);</span><br><span class="line">    QemuOpts *opts = qemu_opts_find(&amp;qemu_vnc_opts, id);</span><br><span class="line">    SocketAddress **saddr = <span class="literal">NULL</span>, **wsaddr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> nsaddr, nwsaddr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *share, *device_id;</span><br><span class="line">    QemuConsole *con;</span><br><span class="line">    <span class="keyword">bool</span> password = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> reverse = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *credid;</span><br><span class="line">    <span class="keyword">bool</span> sasl = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> acl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tlsauthz;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *saslauthz;</span><br><span class="line">    <span class="keyword">int</span> lock_key_sync = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> key_delay_ms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vd) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"VNC display not active"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vnc_display_close(vd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!opts) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse = qemu_opt_get_bool(opts, <span class="string">"reverse"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (vnc_display_get_addresses(opts, reverse, &amp;saddr, &amp;nsaddr,</span><br><span class="line">                                  &amp;wsaddr, &amp;nwsaddr, errp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*设置vnc密码*/</span></span><br><span class="line">    password = qemu_opt_get_bool(opts, <span class="string">"password"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (password) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fips_get_state()) &#123;</span><br><span class="line">            error_setg(errp,</span><br><span class="line">                       <span class="string">"VNC password auth disabled due to FIPS mode, "</span></span><br><span class="line">                       <span class="string">"consider using the VeNCrypt or SASL authentication "</span></span><br><span class="line">                       <span class="string">"methods as an alternative"</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!qcrypto_cipher_supports(</span><br><span class="line">                QCRYPTO_CIPHER_ALG_DES_RFB, QCRYPTO_CIPHER_MODE_ECB)) &#123;</span><br><span class="line">            error_setg(errp,</span><br><span class="line">                       <span class="string">"Cipher backend does not support DES RFB algorithm"</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*numlock和capslock状态同步*/</span></span><br><span class="line">    lock_key_sync = qemu_opt_get_bool(opts, <span class="string">"lock-key-sync"</span>, <span class="literal">true</span>);</span><br><span class="line">    key_delay_ms = qemu_opt_get_number(opts, <span class="string">"key-delay-ms"</span>, <span class="number">10</span>);</span><br><span class="line">    sasl = qemu_opt_get_bool(opts, <span class="string">"sasl"</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_VNC_SASL</span></span><br><span class="line">    <span class="keyword">if</span> (sasl) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"VNC SASL auth requires cyrus-sasl support"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_VNC_SASL */</span></span></span><br><span class="line">    credid = qemu_opt_get(opts, <span class="string">"tls-creds"</span>);</span><br><span class="line">    <span class="keyword">if</span> (credid) &#123;</span><br><span class="line">        Object *creds;</span><br><span class="line">        creds = object_resolve_path_component(</span><br><span class="line">            object_get_objects_root(), credid);</span><br><span class="line">        <span class="keyword">if</span> (!creds) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"No TLS credentials with id '%s'"</span>,</span><br><span class="line">                       credid);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        vd-&gt;tlscreds = (QCryptoTLSCreds *)</span><br><span class="line">            object_dynamic_cast(creds,</span><br><span class="line">                                TYPE_QCRYPTO_TLS_CREDS);</span><br><span class="line">        <span class="keyword">if</span> (!vd-&gt;tlscreds) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"Object with id '%s' is not TLS credentials"</span>,</span><br><span class="line">                       credid);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        object_ref(OBJECT(vd-&gt;tlscreds));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vd-&gt;tlscreds-&gt;endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) &#123;</span><br><span class="line">            error_setg(errp,</span><br><span class="line">                       <span class="string">"Expecting TLS credentials with a server endpoint"</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qemu_opt_get(opts, <span class="string">"acl"</span>)) &#123;</span><br><span class="line">        error_report(<span class="string">"The 'acl' option to -vnc is deprecated. "</span></span><br><span class="line">                     <span class="string">"Please use the 'tls-authz' and 'sasl-authz' "</span></span><br><span class="line">                     <span class="string">"options instead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    acl = qemu_opt_get_bool(opts, <span class="string">"acl"</span>, <span class="literal">false</span>);</span><br><span class="line">    tlsauthz = qemu_opt_get(opts, <span class="string">"tls-authz"</span>);</span><br><span class="line">    <span class="keyword">if</span> (acl &amp;&amp; tlsauthz) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"'acl' option is mutually exclusive with the "</span></span><br><span class="line">                   <span class="string">"'tls-authz' option"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tlsauthz &amp;&amp; !vd-&gt;tlscreds) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"'tls-authz' provided but TLS is not enabled"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saslauthz = qemu_opt_get(opts, <span class="string">"sasl-authz"</span>);</span><br><span class="line">    <span class="keyword">if</span> (acl &amp;&amp; saslauthz) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"'acl' option is mutually exclusive with the "</span></span><br><span class="line">                   <span class="string">"'sasl-authz' option"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (saslauthz &amp;&amp; !sasl) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"'sasl-authz' provided but SASL auth is not enabled"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*设置vnc共享策略*/</span></span><br><span class="line">    share = qemu_opt_get(opts, <span class="string">"share"</span>);</span><br><span class="line">    <span class="keyword">if</span> (share) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(share, <span class="string">"ignore"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            vd-&gt;share_policy = VNC_SHARE_POLICY_IGNORE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(share, <span class="string">"allow-exclusive"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            vd-&gt;share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(share, <span class="string">"force-shared"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            vd-&gt;share_policy = VNC_SHARE_POLICY_FORCE_SHARED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"unknown vnc share= option"</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vd-&gt;share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    vd-&gt;connections_limit = qemu_opt_get_number(opts, <span class="string">"connections"</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VNC_JPEG</span></span><br><span class="line">    vd-&gt;lossy = qemu_opt_get_bool(opts, <span class="string">"lossy"</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    vd-&gt;non_adaptive = qemu_opt_get_bool(opts, <span class="string">"non-adaptive"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/* adaptive updates are only used with tight encoding and</span></span><br><span class="line"><span class="comment">     * if lossy updates are enabled so we can disable all the</span></span><br><span class="line"><span class="comment">     * calculations otherwise */</span></span><br><span class="line">    <span class="keyword">if</span> (!vd-&gt;lossy) &#123;</span><br><span class="line">        vd-&gt;non_adaptive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tlsauthz) &#123;</span><br><span class="line">        vd-&gt;tlsauthzid = g_strdup(tlsauthz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(vd-&gt;id, <span class="string">"default"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            vd-&gt;tlsauthzid = g_strdup(<span class="string">"vnc.x509dname"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vd-&gt;tlsauthzid = g_strdup_printf(<span class="string">"vnc.%s.x509dname"</span>, vd-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        vd-&gt;tlsauthz = QAUTHZ(qauthz_list_new(vd-&gt;tlsauthzid,</span><br><span class="line">                                              QAUTHZ_LIST_POLICY_DENY,</span><br><span class="line">                                              &amp;error_abort));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VNC_SASL</span></span><br><span class="line">    <span class="keyword">if</span> (sasl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (saslauthz) &#123;</span><br><span class="line">            vd-&gt;sasl.authzid = g_strdup(saslauthz);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acl) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(vd-&gt;id, <span class="string">"default"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                vd-&gt;sasl.authzid = g_strdup(<span class="string">"vnc.username"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vd-&gt;sasl.authzid = g_strdup_printf(<span class="string">"vnc.%s.username"</span>, vd-&gt;id);</span><br><span class="line">            &#125;</span><br><span class="line">            vd-&gt;sasl.authz = QAUTHZ(qauthz_list_new(vd-&gt;sasl.authzid,</span><br><span class="line">                                                    QAUTHZ_LIST_POLICY_DENY,</span><br><span class="line">                                                    &amp;error_abort));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*设置vnc认证方式*/</span></span><br><span class="line">    <span class="keyword">if</span> (vnc_display_setup_auth(&amp;vd-&gt;auth, &amp;vd-&gt;subauth,</span><br><span class="line">                               vd-&gt;tlscreds, password,</span><br><span class="line">                               sasl, <span class="literal">false</span>, errp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    trace_vnc_auth_init(vd, <span class="number">0</span>, vd-&gt;auth, vd-&gt;subauth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnc_display_setup_auth(&amp;vd-&gt;ws_auth, &amp;vd-&gt;ws_subauth,</span><br><span class="line">                               vd-&gt;tlscreds, password,</span><br><span class="line">                               sasl, <span class="literal">true</span>, errp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    trace_vnc_auth_init(vd, <span class="number">1</span>, vd-&gt;ws_auth, vd-&gt;ws_subauth);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VNC_SASL</span></span><br><span class="line">    <span class="keyword">if</span> (sasl) &#123;  <span class="comment">/*sasl认证初始化*/</span></span><br><span class="line">        <span class="keyword">int</span> saslErr = sasl_server_init(<span class="literal">NULL</span>, <span class="string">"qemu"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (saslErr != SASL_OK) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"Failed to initialize SASL auth: %s"</span>,</span><br><span class="line">                       sasl_errstring(saslErr, <span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*支持numlock和capslock状态同步*/</span></span><br><span class="line">    vd-&gt;lock_key_sync = lock_key_sync;</span><br><span class="line">    <span class="keyword">if</span> (lock_key_sync) &#123;</span><br><span class="line">        vd-&gt;led = qemu_add_led_event_handler(kbd_leds, vd);</span><br><span class="line">    &#125;</span><br><span class="line">    vd-&gt;ledstate = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*显示设备信息*/</span></span><br><span class="line">    device_id = qemu_opt_get(opts, <span class="string">"display"</span>);</span><br><span class="line">    <span class="keyword">if</span> (device_id) &#123;</span><br><span class="line">        <span class="keyword">int</span> head = qemu_opt_get_number(opts, <span class="string">"head"</span>, <span class="number">0</span>);</span><br><span class="line">        Error *err = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        con = qemu_console_lookup_by_device_name(device_id, head, &amp;err);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            error_propagate(errp, err);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        con = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果不是默认的控制台则重新注册dcl_ops*/</span></span><br><span class="line">    <span class="keyword">if</span> (con != vd-&gt;dcl.con) &#123;</span><br><span class="line">        qkbd_state_free(vd-&gt;kbd);</span><br><span class="line">        unregister_displaychangelistener(&amp;vd-&gt;dcl);</span><br><span class="line">        vd-&gt;dcl.con = con;</span><br><span class="line">        register_displaychangelistener(&amp;vd-&gt;dcl);</span><br><span class="line">        vd-&gt;kbd = qkbd_state_init(vd-&gt;dcl.con);</span><br><span class="line">    &#125;</span><br><span class="line">    qkbd_state_set_delay(vd-&gt;kbd, key_delay_ms);<span class="comment">/*键盘延迟时间*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (saddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vnc_display_connect(vd, saddr, nsaddr, wsaddr, nwsaddr, errp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/*开始监听*/</span></span><br><span class="line">        <span class="keyword">if</span> (vnc_display_listen(vd, saddr, nsaddr, wsaddr, nwsaddr, errp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qemu_opt_get(opts, <span class="string">"to"</span>)) &#123;</span><br><span class="line">        vnc_display_print_local_addr(vd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> cleanup:</span><br><span class="line">    vnc_free_addresses(&amp;saddr, &amp;nsaddr);</span><br><span class="line">    vnc_free_addresses(&amp;wsaddr, &amp;nwsaddr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    vnc_display_close(vd);</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_display_setup_auth函数负责设置vnc客户端连接的认证方式，vnc的认证有方式有：password，sasl,none三种，vnc的Channel可以有clear和tls两种模式，使用tls模式的时候可以使用anon和x509两种类型的证书，所以组合起来有9中方式：</p><ul><li>clear + none</li><li>clear + password</li><li>clear + sasl</li><li>tls + anon + none</li><li>tls + anon + password</li><li>tls + anon + sasl</li><li>tls + x509 + none</li><li>tls + x509 + password</li><li>tls + x509 + sasl</li></ul><p>vnc监听是在vnc_display_listen中完成的，同时注册了连接过来时的处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vnc_display_listen</span><span class="params">(VncDisplay *vd,</span></span></span><br><span class="line"><span class="function"><span class="params">                              SocketAddress **saddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">size_t</span> nsaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              SocketAddress **wsaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">size_t</span> nwsaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="comment">/*tcp监听*/</span></span><br><span class="line">    <span class="keyword">if</span> (nsaddr) &#123;</span><br><span class="line">        vd-&gt;listener = qio_net_listener_new();</span><br><span class="line">        qio_net_listener_set_name(vd-&gt;listener, <span class="string">"vnc-listen"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nsaddr; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (qio_net_listener_open_sync(vd-&gt;listener,</span><br><span class="line">                                           saddr[i],</span><br><span class="line">                                           errp) &lt; <span class="number">0</span>)  &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qio_net_listener_set_client_func(vd-&gt;listener,</span><br><span class="line">                                         vnc_listen_io, vd, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*websocket监听*/</span></span><br><span class="line">    <span class="keyword">if</span> (nwsaddr) &#123;</span><br><span class="line">        vd-&gt;wslistener = qio_net_listener_new();</span><br><span class="line">        qio_net_listener_set_name(vd-&gt;wslistener, <span class="string">"vnc-ws-listen"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nwsaddr; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (qio_net_listener_open_sync(vd-&gt;wslistener,</span><br><span class="line">                                           wsaddr[i],</span><br><span class="line">                                           errp) &lt; <span class="number">0</span>)  &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qio_net_listener_set_client_func(vd-&gt;wslistener,</span><br><span class="line">                                         vnc_listen_io, vd, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中vnc_listen_io是客户端连接时的回调处理函数，到此vnc初始化完成，等待客户端的连接。</p><h2 id="VNC客户端连接流程分析"><a href="#VNC客户端连接流程分析" class="headerlink" title="VNC客户端连接流程分析"></a>VNC客户端连接流程分析</h2><p>上面讲到vnc_listen_io是在vnc客户端连接时触发的回调函数，vnc_listen_io的流程如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vnc_listen_io</span><span class="params">(QIONetListener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params">                          QIOChannelSocket *cioc,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VncDisplay *vd = opaque;</span><br><span class="line">    <span class="comment">/*判断是否为websocket server*/</span></span><br><span class="line">    <span class="keyword">bool</span> isWebsock = listener == vd-&gt;wslistener;</span><br><span class="line">    <span class="comment">/*设置client channel名称*/</span></span><br><span class="line">    qio_channel_set_name(QIO_CHANNEL(cioc),</span><br><span class="line">                         isWebsock ? <span class="string">"vnc-ws-server"</span> : <span class="string">"vnc-server"</span>);</span><br><span class="line">    <span class="comment">/*设置TCPNODELAY*/</span></span><br><span class="line">    qio_channel_set_delay(QIO_CHANNEL(cioc), <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/*真正处理vnc client连接的函数*/</span></span><br><span class="line">    vnc_connect(vd, cioc, <span class="literal">false</span>, isWebsock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_connect是真正处理客户端连接的函数:会为当前连接进来的client分配一个VncState，并，之后初始化VncState中的各项参数:各种buffer(包括input/output buffer，job buffer以及各种压缩方式的buffer),设置AUTH方式，为lossy_rect分配内存，调整gui_update的更新间隔为VNC_REFRESH_INTERVAL_BASE等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vnc_connect</span><span class="params">(VncDisplay *vd, QIOChannelSocket *sioc,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">bool</span> skipauth, <span class="keyword">bool</span> websocket)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">/*设置VncState对应的VncDisplay*/</span></span><br><span class="line">    VncState *vs = g_new0(VncState, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> first_client = QTAILQ_EMPTY(&amp;vd-&gt;clients);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/*将VncState实例加入到对应的VncDisplay的client链表中*/</span></span><br><span class="line">    trace_vnc_client_connect(vs, sioc);</span><br><span class="line">    vs-&gt;magic = VNC_MAGIC;</span><br><span class="line">    vs-&gt;sioc = sioc;</span><br><span class="line">    object_ref(OBJECT(vs-&gt;sioc));</span><br><span class="line">    vs-&gt;ioc = QIO_CHANNEL(sioc);</span><br><span class="line">    object_ref(OBJECT(vs-&gt;ioc));</span><br><span class="line">    vs-&gt;vd = vd;</span><br><span class="line">    <span class="comment">/*初始化input/output buffer，job buffer以及各种压缩方式的buffer)*/</span></span><br><span class="line">    buffer_init(&amp;vs-&gt;input,          <span class="string">"vnc-input/%p"</span>, sioc);</span><br><span class="line">    buffer_init(&amp;vs-&gt;output,         <span class="string">"vnc-output/%p"</span>, sioc);</span><br><span class="line">    buffer_init(&amp;vs-&gt;jobs_buffer,    <span class="string">"vnc-jobs_buffer/%p"</span>, sioc);</span><br><span class="line"></span><br><span class="line">    buffer_init(&amp;vs-&gt;tight.tight,    <span class="string">"vnc-tight/%p"</span>, sioc);</span><br><span class="line">    buffer_init(&amp;vs-&gt;tight.zlib,     <span class="string">"vnc-tight-zlib/%p"</span>, sioc);</span><br><span class="line">    buffer_init(&amp;vs-&gt;tight.gradient, <span class="string">"vnc-tight-gradient/%p"</span>, sioc);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VNC_JPEG</span></span><br><span class="line">    buffer_init(&amp;vs-&gt;tight.jpeg,     <span class="string">"vnc-tight-jpeg/%p"</span>, sioc);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VNC_PNG</span></span><br><span class="line">    buffer_init(&amp;vs-&gt;tight.png,      <span class="string">"vnc-tight-png/%p"</span>, sioc);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    buffer_init(&amp;vs-&gt;zlib.zlib,      <span class="string">"vnc-zlib/%p"</span>, sioc);</span><br><span class="line">    buffer_init(&amp;vs-&gt;zrle.zrle,      <span class="string">"vnc-zrle/%p"</span>, sioc);</span><br><span class="line">    buffer_init(&amp;vs-&gt;zrle.fb,        <span class="string">"vnc-zrle-fb/%p"</span>, sioc);</span><br><span class="line">    buffer_init(&amp;vs-&gt;zrle.zlib,      <span class="string">"vnc-zrle-zlib/%p"</span>, sioc);</span><br><span class="line">    <span class="comment">/*设置VNC认证方式*/</span></span><br><span class="line">    <span class="keyword">if</span> (skipauth) &#123;</span><br><span class="line">        vs-&gt;auth = VNC_AUTH_NONE;</span><br><span class="line">        vs-&gt;subauth = VNC_AUTH_INVALID;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (websocket) &#123;</span><br><span class="line">            vs-&gt;auth = vd-&gt;ws_auth;</span><br><span class="line">            vs-&gt;subauth = VNC_AUTH_INVALID;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vs-&gt;auth = vd-&gt;auth;</span><br><span class="line">            vs-&gt;subauth = vd-&gt;subauth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VNC_DEBUG(<span class="string">"Client sioc=%p ws=%d auth=%d subauth=%d\n"</span>,</span><br><span class="line">              sioc, websocket, vs-&gt;auth, vs-&gt;subauth);</span><br><span class="line">    <span class="comment">/*为lossy_rect分配内存*/</span></span><br><span class="line">    vs-&gt;lossy_rect = g_malloc0(VNC_STAT_ROWS * <span class="keyword">sizeof</span> (*vs-&gt;lossy_rect));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; VNC_STAT_ROWS; ++i) &#123;</span><br><span class="line">        vs-&gt;lossy_rect[i] = g_new0(<span class="keyword">uint8_t</span>, VNC_STAT_COLS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*设置gui_update的更新间隔时间*/</span></span><br><span class="line">    VNC_DEBUG(<span class="string">"New client on socket %p\n"</span>, vs-&gt;sioc);</span><br><span class="line">    update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_BASE);</span><br><span class="line">    <span class="comment">/*设置socket为nonblocking*/</span></span><br><span class="line">    qio_channel_set_blocking(vs-&gt;ioc, <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;ioc_tag) &#123;</span><br><span class="line">        g_source_remove(vs-&gt;ioc_tag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (websocket) &#123;</span><br><span class="line">        <span class="comment">/*设置websocket握手以及数据收发的回调处理函数*/</span></span><br><span class="line">        vs-&gt;websocket = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (vd-&gt;tlscreds) &#123;</span><br><span class="line">            vs-&gt;ioc_tag = qio_channel_add_watch(</span><br><span class="line">                vs-&gt;ioc, G_IO_IN, vncws_tls_handshake_io, vs, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vs-&gt;ioc_tag = qio_channel_add_watch(</span><br><span class="line">                vs-&gt;ioc, G_IO_IN, vncws_handshake_io, vs, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*设置数据收发的回调处理函数*/</span></span><br><span class="line">        vs-&gt;ioc_tag = qio_channel_add_watch(</span><br><span class="line">            vs-&gt;ioc, G_IO_IN, vnc_client_io, vs, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这里是将client地址缓存起来*/</span></span><br><span class="line">    vnc_client_cache_addr(vs);</span><br><span class="line">    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);</span><br><span class="line">    <span class="comment">/*更新VNC的连接数*/</span></span><br><span class="line">    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);</span><br><span class="line"></span><br><span class="line">    vs-&gt;last_x = <span class="number">-1</span>;</span><br><span class="line">    vs-&gt;last_y = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/*设置音频的采样率为44100Hz，通道为双声道，16位*/</span></span><br><span class="line">    vs-&gt;as.freq = <span class="number">44100</span>;</span><br><span class="line">    vs-&gt;as.nchannels = <span class="number">2</span>;</span><br><span class="line">    vs-&gt;as.fmt = AUDIO_FORMAT_S16;</span><br><span class="line">    vs-&gt;as.endianness = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    qemu_mutex_init(&amp;vs-&gt;output_mutex);</span><br><span class="line">    <span class="comment">/*注册一个bh，回调处理函数位vnc_jobs_bh，这里用到了qemu的aio*/</span></span><br><span class="line">    vs-&gt;bh = qemu_bh_new(vnc_jobs_bh, vs);</span><br><span class="line">    <span class="comment">/*将VncState实例加入到对应的VncDisplay的client链表中*/</span></span><br><span class="line">    QTAILQ_INSERT_TAIL(&amp;vd-&gt;clients, vs, next);</span><br><span class="line">    <span class="keyword">if</span> (first_client) &#123;</span><br><span class="line">        <span class="comment">/*初始化显存内存缓存空间*/</span></span><br><span class="line">        vnc_update_server_surface(vd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*触发显卡设备刷新，在显示设备的gfx_update中都会调用dpx_gfx_update，即将更新区域通知给vnc*/</span></span><br><span class="line">    graphic_hw_update(vd-&gt;dcl.con);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vs-&gt;websocket) &#123;</span><br><span class="line">        <span class="comment">/*这里开始vnc的RFB协议交互*/</span></span><br><span class="line">        vnc_start_protocol(vs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果连接超出，将disconnect这个client*/</span></span><br><span class="line">    <span class="keyword">if</span> (vd-&gt;num_connecting &gt; vd-&gt;connections_limit) &#123;</span><br><span class="line">        QTAILQ_FOREACH(vs, &amp;vd-&gt;clients, next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vs-&gt;share_mode == VNC_SHARE_MODE_CONNECTING) &#123;</span><br><span class="line">                vnc_disconnect_start(vs);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_connect中调用qio_channel_add_watch注册的回调处理函数vnc_client_io负责对client进行数据读写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gboolean <span class="title">vnc_client_io</span><span class="params">(QIOChannel *ioc G_GNUC_UNUSED,</span></span></span><br><span class="line"><span class="function"><span class="params">                       GIOCondition condition, <span class="keyword">void</span> *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VncState *vs = opaque;</span><br><span class="line"></span><br><span class="line">    assert(vs-&gt;magic == VNC_MAGIC);</span><br><span class="line">    <span class="keyword">if</span> (condition &amp; G_IO_IN) &#123;</span><br><span class="line">    <span class="comment">/*将数据读取到VncState中的input buffer,之后调用回调read_handler进行读取数据处理*/</span></span><br><span class="line">        <span class="keyword">if</span> (vnc_client_read(vs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* vs is free()ed here */</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (condition &amp; G_IO_OUT) &#123;</span><br><span class="line">    <span class="comment">/*将VncState中的output buffer数据通过QIOChannel的write操作发送给client*/</span></span><br><span class="line">        vnc_client_write(vs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;disconnecting) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vs-&gt;ioc_tag != <span class="number">0</span>) &#123;</span><br><span class="line">            g_source_remove(vs-&gt;ioc_tag);</span><br><span class="line">        &#125;</span><br><span class="line">        vs-&gt;ioc_tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_update_server_surface用于初始化显存内容缓存空间以及设置更新的像素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vnc_update_server_surface</span><span class="params">(VncDisplay *vd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width, height;</span><br><span class="line"></span><br><span class="line">    qemu_pixman_image_unref(vd-&gt;server);</span><br><span class="line">    vd-&gt;server = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QTAILQ_EMPTY(&amp;vd-&gt;clients)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    width = vnc_width(vd);</span><br><span class="line">    height = vnc_height(vd);</span><br><span class="line">    <span class="comment">/*pixman是一个像素处理库，这里是初始化显存内容的缓存空间*/</span></span><br><span class="line">    vd-&gt;server = pixman_image_create_bits(VNC_SERVER_FB_FORMAT,</span><br><span class="line">                                          width, height,</span><br><span class="line">                                          <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*这里设置dirty map为全部(坐标(0,0),使用整个显示区域的宽和高)，即第一次连接会全像素更新*/</span></span><br><span class="line">    <span class="built_in">memset</span>(vd-&gt;guest.dirty, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(vd-&gt;guest.dirty));</span><br><span class="line">    vnc_set_area_dirty(vd-&gt;guest.dirty, vd, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                       width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VNC协议消息交互流程"><a href="#VNC协议消息交互流程" class="headerlink" title="VNC协议消息交互流程"></a>VNC协议消息交互流程</h2><p>vnc客户端和服务端的协议交互是从vnc_start_protocol函数开始，vnc_start_protocol中首先发送服务端RFB版本，然后注册数据读取回调处理函数为protocol_version：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vnc_start_protocol</span><span class="params">(VncState *vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*将RFB版本写进缓存，vnc_write并不直接调用qio_channel的write操作，而是先写进VncState中的output buffer*/</span></span><br><span class="line">    vnc_write(vs, <span class="string">"RFB 003.008\n"</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">/*vnc_flush才是最终调用QIO_channel的write操作的函数*/</span></span><br><span class="line">    vnc_flush(vs);</span><br><span class="line">    <span class="comment">/*这里会将protocol_version赋值给read_handler，在之前的vnc_client_io中我们知道vnc_client_read会调用read_handler回调函数执行读取操作,这里就是调用protocol_version分析客户端发送过来的版本信息*/</span></span><br><span class="line">    vnc_read_when(vs, protocol_version, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    vs-&gt;mouse_mode_notifier.notify = check_pointer_type_change;</span><br><span class="line">    qemu_add_mouse_mode_change_notifier(&amp;vs-&gt;mouse_mode_notifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>protocol_version这个函数负责接收客户端发过来的版本信息，并调用客户端的Auth处理函数对客户端连接进行认证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">protocol_version</span><span class="params">(VncState *vs, <span class="keyword">uint8_t</span> *version, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> local[<span class="number">13</span>];</span><br><span class="line">    <span class="comment">/*头12个字节为version*/</span></span><br><span class="line">    <span class="built_in">memcpy</span>(local, version, <span class="number">12</span>);</span><br><span class="line">    local[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(local, <span class="string">"RFB %03d.%03d\n"</span>, &amp;vs-&gt;major, &amp;vs-&gt;minor) != <span class="number">2</span>) &#123;</span><br><span class="line">        VNC_DEBUG(<span class="string">"Malformed protocol version %s\n"</span>, local);</span><br><span class="line">        vnc_client_error(vs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VNC_DEBUG(<span class="string">"Client request protocol version %d.%d\n"</span>, vs-&gt;major, vs-&gt;minor);</span><br><span class="line">    <span class="comment">/*客户端主版本必须为3，并且子版本必须为3，4，5，7，8*/</span></span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;major != <span class="number">3</span> ||</span><br><span class="line">        (vs-&gt;minor != <span class="number">3</span> &amp;&amp;</span><br><span class="line">         vs-&gt;minor != <span class="number">4</span> &amp;&amp;</span><br><span class="line">         vs-&gt;minor != <span class="number">5</span> &amp;&amp;</span><br><span class="line">         vs-&gt;minor != <span class="number">7</span> &amp;&amp;</span><br><span class="line">         vs-&gt;minor != <span class="number">8</span>)) &#123;</span><br><span class="line">        VNC_DEBUG(<span class="string">"Unsupported client version\n"</span>);</span><br><span class="line">        vnc_write_u32(vs, VNC_AUTH_INVALID);</span><br><span class="line">        vnc_flush(vs);</span><br><span class="line">        vnc_client_error(vs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Some broken clients report v3.4 or v3.5, which spec requires to be treated</span></span><br><span class="line"><span class="comment">     * as equivalent to v3.3 by servers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;minor == <span class="number">4</span> || vs-&gt;minor == <span class="number">5</span>)</span><br><span class="line">        vs-&gt;minor = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">/*如果子版本等于3，直接进行认证*/</span></span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;minor == <span class="number">3</span>) &#123;</span><br><span class="line">        trace_vnc_auth_start(vs, vs-&gt;auth);</span><br><span class="line">        <span class="keyword">if</span> (vs-&gt;auth == VNC_AUTH_NONE) &#123;</span><br><span class="line">            vnc_write_u32(vs, vs-&gt;auth);</span><br><span class="line">            vnc_flush(vs);</span><br><span class="line">            trace_vnc_auth_pass(vs, vs-&gt;auth);</span><br><span class="line">            start_client_init(vs);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vs-&gt;auth == VNC_AUTH_VNC) &#123;</span><br><span class="line">            VNC_DEBUG(<span class="string">"Tell client VNC auth\n"</span>);</span><br><span class="line">            vnc_write_u32(vs, vs-&gt;auth);</span><br><span class="line">            vnc_flush(vs);</span><br><span class="line">            start_auth_vnc(vs);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            trace_vnc_auth_fail(vs, vs-&gt;auth,</span><br><span class="line">                                <span class="string">"Unsupported auth method for v3.3"</span>, <span class="string">""</span>);</span><br><span class="line">            vnc_write_u32(vs, VNC_AUTH_INVALID);</span><br><span class="line">            vnc_flush(vs);</span><br><span class="line">            vnc_client_error(vs);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*如果子版本不等于3则调用protocol_client_auth进行认证*/</span></span><br><span class="line">        vnc_write_u8(vs, <span class="number">1</span>); <span class="comment">/* num auth */</span></span><br><span class="line">        vnc_write_u8(vs, vs-&gt;auth);</span><br><span class="line">        vnc_read_when(vs, protocol_client_auth, <span class="number">1</span>);</span><br><span class="line">        vnc_flush(vs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>protocol_client_auth用于处理其他版本的认证，之后会根据认证方式选择认证函数：none直接调用start_client_init，vnc认证调用start_auth_vnc，VENCRYPT认证调用start_auth_vencrypt，sasl认证调用start_auth_sasl，除了none认证外，其他认证方式认证完都会调用start_client_init。这里不对认证做具体分析，直接从start_client_init函数开始，start_client_init会调用protocol_client_init初始化client的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_client_init</span><span class="params">(VncState *vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vnc_read_when(vs, protocol_client_init, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">protocol_client_init</span><span class="params">(VncState *vs, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    VncShareMode mode;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    mode = data[<span class="number">0</span>] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;</span><br><span class="line">    <span class="keyword">switch</span> (vs-&gt;vd-&gt;share_policy) &#123;</span><br><span class="line">    <span class="keyword">case</span> VNC_SHARE_POLICY_IGNORE:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ignore the shared flag.  Nothing to do here.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Doesn't conform to the rfb spec but is traditional qemu</span></span><br><span class="line"><span class="comment">         * behavior, thus left here as option for compatibility</span></span><br><span class="line"><span class="comment">         * reasons.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Policy: Allow clients ask for exclusive access.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Implementation: When a client asks for exclusive access,</span></span><br><span class="line"><span class="comment">         * disconnect all others. Shared connects are allowed as long</span></span><br><span class="line"><span class="comment">         * as no exclusive connection exists.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is how the rfb spec suggests to handle the shared flag.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mode == VNC_SHARE_MODE_EXCLUSIVE) &#123;</span><br><span class="line">            VncState *client;</span><br><span class="line">            QTAILQ_FOREACH(client, &amp;vs-&gt;vd-&gt;clients, next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vs == client) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (client-&gt;share_mode != VNC_SHARE_MODE_EXCLUSIVE &amp;&amp;</span><br><span class="line">                    client-&gt;share_mode != VNC_SHARE_MODE_SHARED) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vnc_disconnect_start(client);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mode == VNC_SHARE_MODE_SHARED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vs-&gt;vd-&gt;num_exclusive &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                vnc_disconnect_start(vs);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VNC_SHARE_POLICY_FORCE_SHARED:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Policy: Shared connects only.</span></span><br><span class="line"><span class="comment">         * Implementation: Disallow clients asking for exclusive access.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Useful for shared desktop sessions where you don't want</span></span><br><span class="line"><span class="comment">         * someone forgetting to say -shared when running the vnc</span></span><br><span class="line"><span class="comment">         * client disconnect everybody else.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mode == VNC_SHARE_MODE_EXCLUSIVE) &#123;</span><br><span class="line">            vnc_disconnect_start(vs);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*初始化client的共享模式*/</span></span><br><span class="line">    vnc_set_share_mode(vs, mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*判断连接数是否超限*/</span></span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;vd-&gt;num_shared &gt; vs-&gt;vd-&gt;connections_limit) &#123;</span><br><span class="line">        vnc_disconnect_start(vs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(pixman_image_get_width(vs-&gt;vd-&gt;server) &lt; <span class="number">65536</span> &amp;&amp;</span><br><span class="line">           pixman_image_get_width(vs-&gt;vd-&gt;server) &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(pixman_image_get_height(vs-&gt;vd-&gt;server) &lt; <span class="number">65536</span> &amp;&amp;</span><br><span class="line">           pixman_image_get_height(vs-&gt;vd-&gt;server) &gt;= <span class="number">0</span>);</span><br><span class="line">    vs-&gt;client_width = pixman_image_get_width(vs-&gt;vd-&gt;server);</span><br><span class="line">    vs-&gt;client_height = pixman_image_get_height(vs-&gt;vd-&gt;server);</span><br><span class="line">    <span class="comment">/*将显示的宽高发送给client*/</span></span><br><span class="line">    vnc_write_u16(vs, vs-&gt;client_width);</span><br><span class="line">    vnc_write_u16(vs, vs-&gt;client_height);</span><br><span class="line">    <span class="comment">/*初始化每像素的颜色数据的格式，以及设置write_pixels回调处理函数*/</span></span><br><span class="line">    pixel_format_message(vs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qemu_name) &#123;</span><br><span class="line">        size = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"QEMU (%s)"</span>, qemu_name);</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">            size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"QEMU"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*发送qemu_name*/</span></span><br><span class="line">    vnc_write_u32(vs, size);</span><br><span class="line">    vnc_write(vs, buf, size);</span><br><span class="line">    vnc_flush(vs);</span><br><span class="line">    <span class="comment">/*记录认证信息*/</span></span><br><span class="line">    vnc_client_cache_auth(vs);</span><br><span class="line">    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);</span><br><span class="line">    <span class="comment">/*开始处理vnc客户端发来的消息*/</span></span><br><span class="line">    vnc_read_when(vs, protocol_client_msg, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>protocol_client_msg是接收处理客户端发送消息的函数，主要处理的消息类型有以下几种：<br></p><ul><li>VNC_MSG_CLIENT_SET_PIXEL_FORMAT:用于设置像素格式</li><li>VNC_MSG_CLIENT_SET_ENCODINGS:设置编码方式</li><li>VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:请求framebuffer更新</li><li>VNC_MSG_CLIENT_KEY_EVENT:键盘事件<br></li><li>VNC_MSG_CLIENT_POINTER_EVENT:鼠标事件<br></li><li>VNC_MSG_CLIENT_CUT_TEXT:获取client的剪贴文本<br></li><li>VNC_MSG_CLIENT_QEMU:这个是QEMU特有的消息类型，当收到这个消息的时候会对payload再次解析，获取子类型，根据子类型的值进行处理，子类型包括如下值:<ul><li>VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT：处理扩展键</li><li>VNC_MSG_CLIENT_QEMU_AUDIO：音频设置选项，包括三种子选项：<ul><li>VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE：启用音频</li><li>VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE：禁用音频</li><li>VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT：设置音频格式<br></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">protocol_client_msg</span><span class="params">(VncState *vs, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">uint16_t</span> limit;</span><br><span class="line">    <span class="keyword">uint32_t</span> freq;</span><br><span class="line">    VncDisplay *vd = vs-&gt;vd;</span><br><span class="line">    <span class="comment">/*更新刷新间隔*/</span></span><br><span class="line">    <span class="keyword">if</span> (data[<span class="number">0</span>] &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_BASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (data[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> VNC_MSG_CLIENT_SET_PIXEL_FORMAT:  <span class="comment">/*设置像素格式*/</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        set_pixel_format(vs, read_u8(data, <span class="number">4</span>),</span><br><span class="line">                         read_u8(data, <span class="number">6</span>), read_u8(data, <span class="number">7</span>),</span><br><span class="line">                         read_u16(data, <span class="number">8</span>), read_u16(data, <span class="number">10</span>),</span><br><span class="line">                         read_u16(data, <span class="number">12</span>), read_u8(data, <span class="number">14</span>),</span><br><span class="line">                         read_u8(data, <span class="number">15</span>), read_u8(data, <span class="number">16</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VNC_MSG_CLIENT_SET_ENCODINGS:  <span class="comment">/*设置编码方式*/</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">4</span>) &#123;</span><br><span class="line">            limit = read_u16(data, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (limit &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span> + (limit * <span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            limit = read_u16(data, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> val = read_s32(data, <span class="number">4</span> + (i * <span class="number">4</span>));</span><br><span class="line">            <span class="built_in">memcpy</span>(data + <span class="number">4</span> + (i * <span class="number">4</span>), &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_encodings(vs, (<span class="keyword">int32_t</span> *)(data + <span class="number">4</span>), limit);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        framebuffer_update_request(vs,</span><br><span class="line">                                   read_u8(data, <span class="number">1</span>), read_u16(data, <span class="number">2</span>), read_u16(data, <span class="number">4</span>),</span><br><span class="line">                                   read_u16(data, <span class="number">6</span>), read_u16(data, <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VNC_MSG_CLIENT_KEY_EVENT:  <span class="comment">/*键盘事件*/</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        key_event(vs, read_u8(data, <span class="number">1</span>), read_u32(data, <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VNC_MSG_CLIENT_POINTER_EVENT:  <span class="comment">/*鼠标事件*/</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        pointer_event(vs, read_u8(data, <span class="number">1</span>), read_u16(data, <span class="number">2</span>), read_u16(data, <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VNC_MSG_CLIENT_CUT_TEXT:  <span class="comment">/*文本剪贴*/</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> dlen = read_u32(data, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (dlen &gt; (<span class="number">1</span> &lt;&lt; <span class="number">20</span>)) &#123;</span><br><span class="line">                error_report(<span class="string">"vnc: client_cut_text msg payload has %u bytes"</span></span><br><span class="line">                             <span class="string">" which exceeds our limit of 1MB."</span>, dlen);</span><br><span class="line">                vnc_client_error(vs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">8</span> + dlen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        client_cut_text(vs, read_u32(data, <span class="number">4</span>), data + <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VNC_MSG_CLIENT_QEMU:  <span class="comment">/*qemu相关的消息*/</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (read_u8(data, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">            ext_key_event(vs, read_u16(data, <span class="number">2</span>),</span><br><span class="line">                          read_u32(data, <span class="number">4</span>), read_u32(data, <span class="number">8</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> VNC_MSG_CLIENT_QEMU_AUDIO: <span class="comment">/*是否支持qemu音频*/</span></span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (read_u16 (data, <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE: <span class="comment">/*启用音频*/</span></span><br><span class="line">                audio_add(vs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE: <span class="comment">/*禁用音频*/</span></span><br><span class="line">                audio_del(vs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT: <span class="comment">/*设置音频格式*/</span></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">switch</span> (read_u8(data, <span class="number">4</span>)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: vs-&gt;as.fmt = AUDIO_FORMAT_U8; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: vs-&gt;as.fmt = AUDIO_FORMAT_S8; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: vs-&gt;as.fmt = AUDIO_FORMAT_U16; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: vs-&gt;as.fmt = AUDIO_FORMAT_S16; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>: vs-&gt;as.fmt = AUDIO_FORMAT_U32; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>: vs-&gt;as.fmt = AUDIO_FORMAT_S32; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    VNC_DEBUG(<span class="string">"Invalid audio format %d\n"</span>, read_u8(data, <span class="number">4</span>));</span><br><span class="line">                    vnc_client_error(vs);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vs-&gt;as.nchannels = read_u8(data, <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">if</span> (vs-&gt;as.nchannels != <span class="number">1</span> &amp;&amp; vs-&gt;as.nchannels != <span class="number">2</span>) &#123;</span><br><span class="line">                    VNC_DEBUG(<span class="string">"Invalid audio channel count %d\n"</span>,</span><br><span class="line">                              read_u8(data, <span class="number">5</span>));</span><br><span class="line">                    vnc_client_error(vs);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                freq = read_u32(data, <span class="number">6</span>);</span><br><span class="line">                <span class="comment">/* No official limit for protocol, but 48khz is a sensible</span></span><br><span class="line"><span class="comment">                 * upper bound for trustworthy clients, and this limit</span></span><br><span class="line"><span class="comment">                 * protects calculations involving 'vs-&gt;as.freq' later.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (freq &gt; <span class="number">48000</span>) &#123;</span><br><span class="line">                    VNC_DEBUG(<span class="string">"Invalid audio frequency %u &gt; 48000"</span>, freq);</span><br><span class="line">                    vnc_client_error(vs);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vs-&gt;as.freq = freq;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                VNC_DEBUG(<span class="string">"Invalid audio message %d\n"</span>, read_u8(data, <span class="number">4</span>));</span><br><span class="line">                vnc_client_error(vs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            VNC_DEBUG(<span class="string">"Msg: %d\n"</span>, read_u16(data, <span class="number">0</span>));</span><br><span class="line">            vnc_client_error(vs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        VNC_DEBUG(<span class="string">"Msg: %d\n"</span>, data[<span class="number">0</span>]);</span><br><span class="line">        vnc_client_error(vs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vnc_update_throttle_offset(vs);</span><br><span class="line">    <span class="comment">/*继续调用protocol_client_msg处理后续的消息*/</span></span><br><span class="line">    vnc_read_when(vs, protocol_client_msg, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外说下键盘设备如何处理这些事件的(鼠标设备也是类似)，上面的key_event,最终会调到qemu_input_event_send_key函数，这个函数里会调用qemu_input_event_new_key初始一个新的输入事件，并设置事件类型为INPUT_EVENT_KIND_KEY， 之后调用函数qemu_input_event_send_key发送键盘事件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> InputEvent *<span class="title">qemu_input_event_new_key</span><span class="params">(KeyValue *key, <span class="keyword">bool</span> down)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputEvent *evt = g_new0(InputEvent, <span class="number">1</span>);</span><br><span class="line">    evt-&gt;u.key.data = g_new0(InputKeyEvent, <span class="number">1</span>);</span><br><span class="line">    evt-&gt;type = INPUT_EVENT_KIND_KEY;</span><br><span class="line">    evt-&gt;u.key.data-&gt;key = key;</span><br><span class="line">    evt-&gt;u.key.data-&gt;down = down;</span><br><span class="line">    <span class="keyword">return</span> evt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qemu_input_event_send_key</span><span class="params">(QemuConsole *src, KeyValue *key, <span class="keyword">bool</span> down)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputEvent *evt;</span><br><span class="line">    evt = qemu_input_event_new_key(key, down);</span><br><span class="line">    <span class="keyword">if</span> (QTAILQ_EMPTY(&amp;kbd_queue)) &#123;</span><br><span class="line">        qemu_input_event_send(src, evt);</span><br><span class="line">        qemu_input_event_sync();</span><br><span class="line">        qapi_free_InputEvent(evt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue_count &lt; queue_limit) &#123;</span><br><span class="line">        qemu_input_queue_event(&amp;kbd_queue, src, evt);</span><br><span class="line">        qemu_input_queue_sync(&amp;kbd_queue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        qapi_free_InputEvent(evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>qemu_input_event_send_key函数最终会调到真正执行键盘输入的函数qemu_input_event_send_impl，这个函数里会先找到执行事件的设备handler，然后调用handler的event函数处理InputEvent:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qemu_input_event_send_impl</span><span class="params">(QemuConsole *src, InputEvent *evt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QemuInputHandlerState *s;</span><br><span class="line"></span><br><span class="line">    qemu_input_event_trace(src, evt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pre processing */</span></span><br><span class="line">    <span class="keyword">if</span> (graphic_rotate &amp;&amp; (evt-&gt;type == INPUT_EVENT_KIND_ABS)) &#123;</span><br><span class="line">            qemu_input_transform_abs_rotate(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 找到类型为INPUT_EVENT_KIND_KEY的handler， send event */</span></span><br><span class="line">    s = qemu_input_find_handler(<span class="number">1</span> &lt;&lt; evt-&gt;type, src);</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*调用handler的event函数执行输入事件*/</span></span><br><span class="line">    s-&gt;handler-&gt;event(s-&gt;dev, src, evt);</span><br><span class="line">    s-&gt;events++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handler可以为ps2设备，virtio-tablet,usb-tablet等，这里不再对设备如何处理输入事件详细说明</p><h2 id="framebuffer更新流程"><a href="#framebuffer更新流程" class="headerlink" title="framebuffer更新流程"></a>framebuffer更新流程</h2><p>dc_ops操作集中的回调函数指针dpy_gfx_update是在供显卡设备绘图完成后调用的，负责更新变化区域,vnc中dpy_gfx_update指向的是vnc_dpy_update函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vnc_dpy_update</span><span class="params">(DisplayChangeListener *dcl,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*获取对应的display*/</span></span><br><span class="line">    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VncSurface</span> *<span class="title">s</span> = &amp;<span class="title">vd</span>-&gt;<span class="title">guest</span>;</span></span><br><span class="line">    <span class="comment">/*更新vd中的变化区域*/</span></span><br><span class="line">    vnc_set_area_dirty(s-&gt;dirty, vd, x, y, w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vnc_set_area_dirty</span><span class="params">(DECLARE_BITMAP(dirty[VNC_MAX_HEIGHT],</span></span></span><br><span class="line"><span class="function"><span class="params">                               VNC_MAX_WIDTH / VNC_DIRTY_PIXELS_PER_BIT),</span></span></span><br><span class="line"><span class="function"><span class="params">                               VncDisplay *vd,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*获取display的宽高*/</span></span><br><span class="line">    <span class="keyword">int</span> width = vnc_width(vd);</span><br><span class="line">    <span class="keyword">int</span> height = vnc_height(vd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*增加宽度，以及左移x值，为了确保能覆盖变化区域*/</span></span><br><span class="line">    <span class="comment">/* this is needed this to ensure we updated all affected</span></span><br><span class="line"><span class="comment">     * blocks if x % VNC_DIRTY_PIXELS_PER_BIT != 0 */</span></span><br><span class="line">    w += (x % VNC_DIRTY_PIXELS_PER_BIT);</span><br><span class="line">    x -= (x % VNC_DIRTY_PIXELS_PER_BIT);</span><br><span class="line">    </span><br><span class="line">    x = MIN(x, width);</span><br><span class="line">    y = MIN(y, height);</span><br><span class="line">    w = MIN(x + w, width) - x;</span><br><span class="line">    h = MIN(y + h, height);</span><br><span class="line">    <span class="comment">/*根据上面的w,h,x,y设置bitmap(以像素大小按行更新)*/</span></span><br><span class="line">    <span class="keyword">for</span> (; y &lt; h; y++) &#123;</span><br><span class="line">        bitmap_set(dirty[y], x / VNC_DIRTY_PIXELS_PER_BIT,</span><br><span class="line">                   DIV_ROUND_UP(w, VNC_DIRTY_PIXELS_PER_BIT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显卡设备更新是由dc_ops中的函数指针dpy_refresh触发的，dpy_refresh由上面的gui_setup_refresh创建的定时器调用，dpy_refresh负责获取display中的变化区域内容并创建vncjob插入queue:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vnc_refresh</span><span class="params">(DisplayChangeListener *dcl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);</span><br><span class="line">    VncState *vs, *vn;</span><br><span class="line">    <span class="keyword">int</span> has_dirty, rects = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QTAILQ_EMPTY(&amp;vd-&gt;clients)) &#123;</span><br><span class="line">        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这里触发显卡设备更新，显卡设备更新的最后会调用dpy_gfx_update指针将更新区域设置到bitmap*/</span></span><br><span class="line">    graphic_hw_update(vd-&gt;dcl.con);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnc_trylock_display(vd)) &#123;</span><br><span class="line">        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_BASE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这里会真正获取变化的内容并将变化区域的内存指针赋给vd-&gt;server*/</span></span><br><span class="line">    has_dirty = vnc_refresh_server_surface(vd);</span><br><span class="line">    vnc_unlock_display(vd);</span><br><span class="line">    <span class="comment">/*判断是否有client，有的话则为每个vs创建vncjob并插入到对应的队列中*/</span></span><br><span class="line">    QTAILQ_FOREACH_SAFE(vs, &amp;vd-&gt;clients, next, vn) &#123;</span><br><span class="line">        rects += vnc_update_client(vs, has_dirty);</span><br><span class="line">        <span class="comment">/* vs might be free()ed here */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果图像有变化就缩短刷新间隔，提供更高帧率*/</span></span><br><span class="line">    <span class="keyword">if</span> (has_dirty &amp;&amp; rects) &#123;</span><br><span class="line">        vd-&gt;dcl.update_interval /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (vd-&gt;dcl.update_interval &lt; VNC_REFRESH_INTERVAL_BASE) &#123;</span><br><span class="line">            vd-&gt;dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vd-&gt;dcl.update_interval += VNC_REFRESH_INTERVAL_INC;</span><br><span class="line">        <span class="keyword">if</span> (vd-&gt;dcl.update_interval &gt; VNC_REFRESH_INTERVAL_MAX) &#123;</span><br><span class="line">            vd-&gt;dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_update_client负责创建vncjob，并根据bitmap中的dirty区域计算起始坐标(x,y)，之后将变化区域的w,h,x,y设置到VncRectEntry实例中并加入到vncjob中的rectangles链表中，之后将vncjob加入到queue中并通知worker线程消费queue:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vnc_update_client</span><span class="params">(VncState *vs, <span class="keyword">int</span> has_dirty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VncDisplay *vd = vs-&gt;vd;</span><br><span class="line">    VncJob *job;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> height, width;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;disconnecting) &#123;</span><br><span class="line">        vnc_disconnect_finish(vs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*判断是否需要更新*/</span></span><br><span class="line">    vs-&gt;has_dirty += has_dirty;</span><br><span class="line">    <span class="keyword">if</span> (!vnc_should_update(vs)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vs-&gt;has_dirty &amp;&amp; vs-&gt;update != VNC_STATE_UPDATE_FORCE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Send screen updates to the vnc client using the server</span></span><br><span class="line"><span class="comment">     * surface and server dirty map.  guest surface updates</span></span><br><span class="line"><span class="comment">     * happening in parallel don't disturb us, the next pass will</span></span><br><span class="line"><span class="comment">     * send them to the client.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*创建job*/</span></span><br><span class="line">    job = vnc_job_new(vs);</span><br><span class="line"></span><br><span class="line">    height = pixman_image_get_height(vd-&gt;server);</span><br><span class="line">    width = pixman_image_get_width(vd-&gt;server);</span><br><span class="line">    <span class="comment">/*计算x,y值并在vnc_job_add_rect中创建rect然后加入到vncjob的rectangles链表中*/</span></span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, h;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> x2;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> offset = find_next_bit((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) &amp;vs-&gt;dirty,</span><br><span class="line">                                             height * VNC_DIRTY_BPL(vs),</span><br><span class="line">                                             y * VNC_DIRTY_BPL(vs));</span><br><span class="line">        <span class="keyword">if</span> (offset == height * VNC_DIRTY_BPL(vs)) &#123;</span><br><span class="line">            <span class="comment">/* no more dirty bits */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        y = offset / VNC_DIRTY_BPL(vs);</span><br><span class="line">        x = offset % VNC_DIRTY_BPL(vs);</span><br><span class="line">        x2 = find_next_zero_bit((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) &amp;vs-&gt;dirty[y],</span><br><span class="line">                                VNC_DIRTY_BPL(vs), x);</span><br><span class="line">        bitmap_clear(vs-&gt;dirty[y], x, x2 - x);</span><br><span class="line">        h = find_and_clear_dirty_height(vs, y, x, x2, height);</span><br><span class="line">        x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);</span><br><span class="line">        <span class="keyword">if</span> (x2 &gt; x) &#123;</span><br><span class="line">            n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,</span><br><span class="line">                                  (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!x &amp;&amp; x2 == width / VNC_DIRTY_PIXELS_PER_BIT) &#123;</span><br><span class="line">            y += h;</span><br><span class="line">            <span class="keyword">if</span> (y == height) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vs-&gt;job_update = vs-&gt;update;</span><br><span class="line">    vs-&gt;update = VNC_STATE_UPDATE_NONE;</span><br><span class="line">    <span class="comment">/*将job加入到queue，然后通知worker线程消费*/</span></span><br><span class="line">    vnc_job_push(job);</span><br><span class="line">    vs-&gt;has_dirty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要提到VNC的更新方式，我们知道VNC更新有三个选项:<br>VNC_STATE_UPDATE_NONE代表不更新给client;<br><br>VNC_STATE_UPDATE_INCREMENTAL代表低于缓存阈值的时候更新;<br>VNC_STATE_UPDATE_FORCE表示强制更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    VNC_STATE_UPDATE_NONE,</span><br><span class="line">    VNC_STATE_UPDATE_INCREMENTAL,</span><br><span class="line">    VNC_STATE_UPDATE_FORCE,</span><br><span class="line">&#125; VncStateUpdate;</span><br></pre></td></tr></table></figure><p>VNC更新请求由客户端发起，在之前的protocol_client_msg中可以看到,VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST就是client发过来的请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    framebuffer_update_request(vs,read_u8(data, <span class="number">1</span>), read_u16(data, <span class="number">2</span>), read_u16(data, <span class="number">4</span>),read_u16(data, <span class="number">6</span>), read_u16(data, <span class="number">8</span>));</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>framebuffer_update_request根据client发过来的incremental是否为真决定采用哪种更新方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">framebuffer_update_request</span><span class="params">(VncState *vs, <span class="keyword">int</span> incremental,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (incremental) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vs-&gt;update != VNC_STATE_UPDATE_FORCE) &#123;</span><br><span class="line">            vs-&gt;update = VNC_STATE_UPDATE_INCREMENTAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vs-&gt;update = VNC_STATE_UPDATE_FORCE;</span><br><span class="line">        vnc_set_area_dirty(vs-&gt;dirty, vs-&gt;vd, x, y, w, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="framebuffer发送流程"><a href="#framebuffer发送流程" class="headerlink" title="framebuffer发送流程"></a>framebuffer发送流程</h2><p>vnc_start_worker_thread会创建线程用来处理framebuffer更新(即消费上面的vncjob并将framebuffer发送给client)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">vnc_worker_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VncJobQueue *<span class="built_in">queue</span> = arg;</span><br><span class="line"></span><br><span class="line">    qemu_thread_get_self(&amp;<span class="built_in">queue</span>-&gt;thread);</span><br><span class="line">    <span class="comment">/*vnc_worker_thread_loop里是真正处理frameupdate的函数*/</span></span><br><span class="line">    <span class="keyword">while</span> (!vnc_worker_thread_loop(<span class="built_in">queue</span>)) ;</span><br><span class="line">    vnc_queue_clear(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vnc_start_worker_thread</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VncJobQueue *q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnc_worker_thread_running())</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">/*创建VncJobQueue，所有将要更新的frame都挂到这个queue上*/</span></span><br><span class="line">    q = vnc_queue_init();</span><br><span class="line">    <span class="comment">/*创建vnc_worker线程，执行函数是vnc_worker_thread*/</span></span><br><span class="line">    qemu_thread_create(&amp;q-&gt;thread, <span class="string">"vnc_worker"</span>, vnc_worker_thread, q,</span><br><span class="line">                       QEMU_THREAD_DETACHED);</span><br><span class="line">    <span class="built_in">queue</span> = q; <span class="comment">/* Set global queue */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_worker_thread_loop里是真正处理frameupdate的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vnc_worker_thread_loop</span><span class="params">(VncJobQueue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VncJob *job; <span class="comment">/*每次从queue上取一个VncJob处理*/</span></span><br><span class="line">    VncRectEntry *entry, *tmp; <span class="comment">/*更新区域*/</span></span><br><span class="line">    VncState vs = &#123;&#125;; <span class="comment">/*vnc client*/</span></span><br><span class="line">    <span class="keyword">int</span> n_rectangles;</span><br><span class="line">    <span class="keyword">int</span> saved_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*等待queue上有job出现*/</span></span><br><span class="line">    vnc_lock_queue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">while</span> (QTAILQ_EMPTY(&amp;<span class="built_in">queue</span>-&gt;jobs) &amp;&amp; !<span class="built_in">queue</span>-&gt;<span class="built_in">exit</span>) &#123;</span><br><span class="line">        qemu_cond_wait(&amp;<span class="built_in">queue</span>-&gt;cond, &amp;<span class="built_in">queue</span>-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Here job can only be NULL if queue-&gt;exit is true */</span></span><br><span class="line">    job = QTAILQ_FIRST(&amp;<span class="built_in">queue</span>-&gt;jobs);</span><br><span class="line">    vnc_unlock_queue(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="comment">/*判断魔法数字是否正确*/</span></span><br><span class="line">    assert(job-&gt;vs-&gt;magic == VNC_MAGIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;<span class="built_in">exit</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取job后，锁住job对应的vs的output锁*/</span></span><br><span class="line">    vnc_lock_output(job-&gt;vs);</span><br><span class="line">    <span class="keyword">if</span> (job-&gt;vs-&gt;ioc == <span class="literal">NULL</span> || job-&gt;vs-&gt;<span class="built_in">abort</span> == <span class="literal">true</span>) &#123;</span><br><span class="line">        vnc_unlock_output(job-&gt;vs);</span><br><span class="line">        <span class="keyword">goto</span> disconnected;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buffer_empty(&amp;job-&gt;vs-&gt;output)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Looks like a NOP as it obviously moves no data.  But it</span></span><br><span class="line"><span class="comment">         * moves the empty buffer, so we don't have to malloc a new</span></span><br><span class="line"><span class="comment">         * one for vs.output</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        buffer_move_empty(&amp;vs.output, &amp;job-&gt;vs-&gt;output);</span><br><span class="line">    &#125;</span><br><span class="line">    vnc_unlock_output(job-&gt;vs);</span><br><span class="line">     <span class="comment">/*开始拷贝output buffers，同时将rectangles发送给client*/</span></span><br><span class="line">    <span class="comment">/* Make a local copy of vs and switch output buffers */</span></span><br><span class="line">    vnc_async_encoding_start(job-&gt;vs, &amp;vs);</span><br><span class="line">    vs.magic = VNC_MAGIC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始通过VNC_MSG_SERVER_FRAMEBUFFER_UPDATE消息发送rectangles*/</span></span><br><span class="line">    n_rectangles = <span class="number">0</span>;</span><br><span class="line">    vnc_write_u8(&amp;vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);</span><br><span class="line">    vnc_write_u8(&amp;vs, <span class="number">0</span>);</span><br><span class="line">    saved_offset = vs.output.offset;</span><br><span class="line">    vnc_write_u16(&amp;vs, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    vnc_lock_display(job-&gt;vs-&gt;vd);</span><br><span class="line">    <span class="comment">/*将job下的所有rectangles发送给client*/</span></span><br><span class="line">    QLIST_FOREACH_SAFE(entry, &amp;job-&gt;rectangles, next, tmp) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (job-&gt;vs-&gt;ioc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            vnc_unlock_display(job-&gt;vs-&gt;vd);</span><br><span class="line">            <span class="comment">/* Copy persistent encoding data */</span></span><br><span class="line">            vnc_async_encoding_end(job-&gt;vs, &amp;vs);</span><br><span class="line">            <span class="keyword">goto</span> disconnected;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*这里会对将要发送的数据编码，然后发送*/</span></span><br><span class="line">        n = vnc_send_framebuffer_update(&amp;vs, entry-&gt;rect.x, entry-&gt;rect.y,entry-&gt;rect.w, entry-&gt;rect.h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            n_rectangles += n;</span><br><span class="line">        &#125;</span><br><span class="line">        g_free(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    vnc_unlock_display(job-&gt;vs-&gt;vd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Put n_rectangles at the beginning of the message */</span></span><br><span class="line">    vs.output.buffer[saved_offset] = (n_rectangles &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    vs.output.buffer[saved_offset + <span class="number">1</span>] = n_rectangles &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    vnc_lock_output(job-&gt;vs);</span><br><span class="line">    <span class="keyword">if</span> (job-&gt;vs-&gt;ioc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        buffer_move(&amp;job-&gt;vs-&gt;jobs_buffer, &amp;vs.output);</span><br><span class="line">        <span class="comment">/* Copy persistent encoding data */</span></span><br><span class="line">        vnc_async_encoding_end(job-&gt;vs, &amp;vs);</span><br><span class="line"></span><br><span class="line">        qemu_bh_schedule(job-&gt;vs-&gt;bh);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer_reset(&amp;vs.output);</span><br><span class="line">        <span class="comment">/* Copy persistent encoding data */</span></span><br><span class="line">        vnc_async_encoding_end(job-&gt;vs, &amp;vs);</span><br><span class="line">    &#125;</span><br><span class="line">    vnc_unlock_output(job-&gt;vs);</span><br><span class="line"></span><br><span class="line">disconnected:</span><br><span class="line">    vnc_lock_queue(<span class="built_in">queue</span>);</span><br><span class="line">    QTAILQ_REMOVE(&amp;<span class="built_in">queue</span>-&gt;jobs, job, next);</span><br><span class="line">    vnc_unlock_queue(<span class="built_in">queue</span>);</span><br><span class="line">    qemu_cond_broadcast(&amp;<span class="built_in">queue</span>-&gt;cond);</span><br><span class="line">    g_free(job);</span><br><span class="line">    vs.magic = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_send_framebuffer_update是负责对变化区域的数据进行编码及发送的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vnc_send_framebuffer_update</span><span class="params">(VncState *vs, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> encode_raw = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">size_t</span> saved_offs = vs-&gt;output.offset;</span><br><span class="line">    <span class="comment">/*根据client的encoding类型选择对应的编码方式进行编码*/</span></span><br><span class="line">    <span class="keyword">switch</span>(vs-&gt;vnc_encoding) &#123;</span><br><span class="line">        <span class="keyword">case</span> VNC_ENCODING_ZLIB:</span><br><span class="line">            n = vnc_zlib_send_framebuffer_update(vs, x, y, w, h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> VNC_ENCODING_HEXTILE:</span><br><span class="line">            vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_HEXTILE);</span><br><span class="line">            n = vnc_hextile_send_framebuffer_update(vs, x, y, w, h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> VNC_ENCODING_TIGHT:</span><br><span class="line">            n = vnc_tight_send_framebuffer_update(vs, x, y, w, h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> VNC_ENCODING_TIGHT_PNG:</span><br><span class="line">            n = vnc_tight_png_send_framebuffer_update(vs, x, y, w, h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> VNC_ENCODING_ZRLE:</span><br><span class="line">            n = vnc_zrle_send_framebuffer_update(vs, x, y, w, h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> VNC_ENCODING_ZYWRLE:</span><br><span class="line">            n = vnc_zywrle_send_framebuffer_update(vs, x, y, w, h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            encode_raw = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the client has the same pixel format as our internal buffer and</span></span><br><span class="line"><span class="comment">     * a RAW encoding would need less space fall back to RAW encoding to</span></span><br><span class="line"><span class="comment">     * save bandwidth and processing power in the client. */</span></span><br><span class="line">    <span class="keyword">if</span> (!encode_raw &amp;&amp; vs-&gt;write_pixels == vnc_write_pixels_copy &amp;&amp;</span><br><span class="line">        <span class="number">12</span> + h * w * VNC_SERVER_FB_BYTES &lt;= (vs-&gt;output.offset - saved_offs)) &#123;</span><br><span class="line">        vs-&gt;output.offset = saved_offs;</span><br><span class="line">        encode_raw = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*裸数据发送*/</span></span><br><span class="line">    <span class="keyword">if</span> (encode_raw) &#123;</span><br><span class="line">        vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_RAW);</span><br><span class="line">        n = vnc_raw_send_framebuffer_update(vs, x, y, w, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_raw_send_framebuffer_update负责将数据通过pixman库转换后写入到vs的output buffer中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vnc_raw_send_framebuffer_update</span><span class="params">(VncState *vs, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">uint8_t</span> *row;</span><br><span class="line">    VncDisplay *vd = vs-&gt;vd;</span><br><span class="line"></span><br><span class="line">    row = vnc_server_fb_ptr(vd, x, y);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">        <span class="comment">/*之前在protocol_client_init里调用pixel_format_message设置write_pixels的回调函数为vnc_write_pixels_copy，这里最后就调用到vnc_write_pixels_copy*/</span></span><br><span class="line">        vs-&gt;write_pixels(vs, row, w * VNC_SERVER_FB_BYTES);</span><br><span class="line">        row += vnc_server_fb_stride(vd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnc_write_pixels_copy最后会调用vnc_write将数据发送给client：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Scale factor to apply to vs-&gt;throttle_output_offset when checking for</span></span><br><span class="line"><span class="comment"> * hard limit. Worst case normal usage could be x2, if we have a complete</span></span><br><span class="line"><span class="comment"> * incremental update and complete forced update in the output buffer.</span></span><br><span class="line"><span class="comment"> * So x3 should be good enough, but we pick x5 to be conservative and thus</span></span><br><span class="line"><span class="comment"> * (hopefully) never trigger incorrectly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*阈值是用来防止client恶意的不停请求致使buffer溢出*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VNC_THROTTLE_OUTPUT_LIMIT_SCALE 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vnc_write</span><span class="params">(VncState *vs, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(vs-&gt;magic == VNC_MAGIC);</span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;disconnecting) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Protection against malicious client/guest to prevent our output</span></span><br><span class="line"><span class="comment">     * buffer growing without bound if client stops reading data. This</span></span><br><span class="line"><span class="comment">     * should rarely trigger, because we have earlier throttling code</span></span><br><span class="line"><span class="comment">     * which stops issuing framebuffer updates and drops audio data</span></span><br><span class="line"><span class="comment">     * if the throttle_output_offset value is exceeded. So we only reach</span></span><br><span class="line"><span class="comment">     * this higher level if a huge number of pseudo-encodings get</span></span><br><span class="line"><span class="comment">     * triggered while data can't be sent on the socket.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * NB throttle_output_offset can be zero during early protocol</span></span><br><span class="line"><span class="comment">     * handshake, or from the job thread's VncState clone</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;throttle_output_offset != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (vs-&gt;output.offset / VNC_THROTTLE_OUTPUT_LIMIT_SCALE) &gt;</span><br><span class="line">        vs-&gt;throttle_output_offset) &#123;</span><br><span class="line">        trace_vnc_client_output_limit(vs, vs-&gt;ioc, vs-&gt;output.offset,</span><br><span class="line">                                      vs-&gt;throttle_output_offset);</span><br><span class="line">        vnc_disconnect_start(vs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer_reserve(&amp;vs-&gt;output, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vs-&gt;ioc != <span class="literal">NULL</span> &amp;&amp; buffer_empty(&amp;vs-&gt;output)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vs-&gt;ioc_tag) &#123;</span><br><span class="line">            g_source_remove(vs-&gt;ioc_tag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*这里是判断vnc_client_io处理有没有启用，没有的话启动vnc_client_io处理线程处理数据发送*/</span></span><br><span class="line">        vs-&gt;ioc_tag = qio_channel_add_watch(</span><br><span class="line">            vs-&gt;ioc, G_IO_IN | G_IO_OUT, vnc_client_io, vs, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将数据添加到output buffer中，之后vnc_client_io会将buffer发送*/</span></span><br><span class="line">    buffer_append(&amp;vs-&gt;output, data, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VNC介绍&quot;&gt;&lt;a href=&quot;#VNC介绍&quot; class=&quot;headerlink&quot; title=&quot;VNC介绍&quot;&gt;&lt;/a&gt;VNC介绍&lt;/h2&gt;&lt;p&gt;vnc是一个桌面传输协议，使用的是RFB协议格式，RFB协议是一个基于TCP的应用层传输协议。基于vnc协议实现的程
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://huazq.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="qemu" scheme="https://huazq.github.io/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机性能优化</title>
    <link href="https://huazq.github.io/2019/08/13/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://huazq.github.io/2019/08/13/虚拟机性能优化/</id>
    <published>2019-08-13T07:00:00.000Z</published>
    <updated>2019-08-13T09:18:52.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-CPU优化"><a href="#一-CPU优化" class="headerlink" title="一.CPU优化"></a>一.CPU优化</h2><p>提升虚拟机cpu性能的手段，包括<strong>CPU透传</strong>, <strong>CPU缓存</strong>, <strong>CPU亲和性</strong>以及<strong>CPU线程调度策略</strong></p><h3 id="1-CPU透传"><a href="#1-CPU透传" class="headerlink" title="1.CPU透传"></a>1.CPU透传</h3><p>CPU透传是指将host的CPU信息对guest可见，由于guest中某些软件算法会依赖特定的CPU指令，通过透传可以提高这些软件算法的性能，libvirt中CPU透传的配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpu</span> <span class="attr">mode</span>=<span class="string">'host-passthrough'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">mode</span>=<span class="string">'passthrough'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">'disable'</span> <span class="attr">name</span>=<span class="string">'lahf_lm'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>cache mode设置为passthrough，意味着通过将host的cache信息透传给虚拟机，虽然cpu是透传模式，但也可以配置cpu的某些feature是启用还是禁用。</p><h3 id="2-CPU亲和性"><a href="#2-CPU亲和性" class="headerlink" title="2.CPU亲和性"></a>2.CPU亲和性</h3><p>CPU亲和性是指将vcpu、qemu主线程、io线程绑定到某个或某些物理cpu上，减少cpu调度，提高虚拟机的性能，CPU亲和性在libvirt中配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cputune</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpupin</span> <span class="attr">vcpu</span>=<span class="string">'0'</span> <span class="attr">cpuset</span>=<span class="string">'0'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpupin</span> <span class="attr">vcpu</span>=<span class="string">'1'</span> <span class="attr">cpuset</span>=<span class="string">'1'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">emulatorpin</span> <span class="attr">cpuset</span>=<span class="string">'1'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iothreadpin</span> <span class="attr">iothread</span>=<span class="string">'1'</span> <span class="attr">cpuset</span>=<span class="string">'2'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iothreadpin</span> <span class="attr">iothread</span>=<span class="string">'2'</span> <span class="attr">cpuset</span>=<span class="string">'3'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cputune</span>&gt;</span></span><br></pre></td></tr></table></figure><p>vcpupin是指将指定vcpu绑定到指定的cpuset上，emulatorpin以及iothreadpin的绑定方式也是如此</p><h4 id="3-CPU线程调度策略"><a href="#3-CPU线程调度策略" class="headerlink" title="3.CPU线程调度策略"></a>3.CPU线程调度策略</h4><p>CPU调度策略是指通过调度sched_setscheduler设置指定线程的调度策略，以及调度优先级，cpu调度策略在libvirt中配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cputune</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpusched</span> <span class="attr">vcpus</span>=<span class="string">'0'</span> <span class="attr">scheduler</span>=<span class="string">'fifo'</span> <span class="attr">priority</span>=<span class="string">'0'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpusched</span> <span class="attr">vcpus</span>=<span class="string">'1'</span> <span class="attr">scheduler</span>=<span class="string">'fifo'</span> <span class="attr">priority</span>=<span class="string">'0'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iothreadsched</span> <span class="attr">iothreads</span>=<span class="string">'1'</span> <span class="attr">scheduler</span>=<span class="string">'rr'</span> <span class="attr">priority</span>=<span class="string">'0'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iothreadsched</span> <span class="attr">iothreads</span>=<span class="string">'2'</span> <span class="attr">scheduler</span>=<span class="string">'rr'</span> <span class="attr">priority</span>=<span class="string">'0'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iothreadsched</span> <span class="attr">iothreads</span>=<span class="string">'3'</span> <span class="attr">scheduler</span>=<span class="string">'rr'</span> <span class="attr">priority</span>=<span class="string">'0'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">emulatorsched</span> <span class="attr">scheduler</span>=<span class="string">'rr'</span> <span class="attr">priority</span>=<span class="string">'0'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cputune</span>&gt;</span></span><br></pre></td></tr></table></figure><p>libvirt支持的调度策略包括以下几个:<br>none表示普通进程，采用cfs调度;<br>batch是普通进程调度策略的分化版本。采用分时策略，根据动态优先级(nice()API设置），分配CPU运算资源；<br>idle表示在系统空闲时才跑这类进程，优先级最低;<br>fifo表示先入先出调度算法，属于实时调度策略，相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级的任务;<br>rr表示时间片轮转调度算法，也属于实时调度策略，使用 Roound-Robin算法，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，同样，高优先级的任务可以抢占低优先级的任务。</p><h3 id="4-CPU-cache"><a href="#4-CPU-cache" class="headerlink" title="4.CPU cache"></a>4.CPU cache</h3><p>CPU cache功能是在Qemu v2.8.0-rc0开始合入qemu(<a href="https://git.qemu.org/?p=qemu.git;a=commit;h=14c985cffa6cb177fc01a163d8bcf227c104718c" target="_blank" rel="noopener">链接</a>)，可以通过”-cpu l3-cache=on”方式为虚拟机的cpu创建一个l3的cache,l3 cache的支持可以显著的减少IPI中断(一种cpu之间的中断)，原因是一些软件算法是基于硬件cache信息实现的, 例如在x86 kernel中, 当cpu1想在cpu2唤醒一个任务时, cpu1会触发一个resched IPI 中断，并且告诉cpu2如果不共享低级别缓存，就需要去唤醒这个任务. 相反，如果cpu2有低级别缓存， cpu1 可以直接访问cpu2的runqueue，从而不需要通过IPI中断.cpu cache在libvirt中的配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cachetune</span> <span class="attr">vcpus</span>=<span class="string">'0-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">id</span>=<span class="string">'0'</span> <span class="attr">level</span>=<span class="string">'3'</span> <span class="attr">type</span>=<span class="string">'both'</span> <span class="attr">size</span>=<span class="string">'3'</span> <span class="attr">unit</span>=<span class="string">'MiB'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">id</span>=<span class="string">'1'</span> <span class="attr">level</span>=<span class="string">'3'</span> <span class="attr">type</span>=<span class="string">'both'</span> <span class="attr">size</span>=<span class="string">'3'</span> <span class="attr">unit</span>=<span class="string">'MiB'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">monitor</span> <span class="attr">level</span>=<span class="string">'3'</span> <span class="attr">vcpus</span>=<span class="string">'1'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">monitor</span> <span class="attr">level</span>=<span class="string">'3'</span> <span class="attr">vcpus</span>=<span class="string">'0-3'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cachetune</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cachetune</span> <span class="attr">vcpus</span>=<span class="string">'4-5'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">monitor</span> <span class="attr">level</span>=<span class="string">'3'</span> <span class="attr">vcpus</span>=<span class="string">'4'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">monitor</span> <span class="attr">level</span>=<span class="string">'3'</span> <span class="attr">vcpus</span>=<span class="string">'5'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cachetune</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-CPU优化&quot;&gt;&lt;a href=&quot;#一-CPU优化&quot; class=&quot;headerlink&quot; title=&quot;一.CPU优化&quot;&gt;&lt;/a&gt;一.CPU优化&lt;/h2&gt;&lt;p&gt;提升虚拟机cpu性能的手段，包括&lt;strong&gt;CPU透传&lt;/strong&gt;, &lt;strong&gt;CP
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://huazq.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="libvirt" scheme="https://huazq.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机资源Qos分析</title>
    <link href="https://huazq.github.io/2019/08/10/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%B5%84%E6%BA%90%E5%A4%8D%E7%94%A8/"/>
    <id>https://huazq.github.io/2019/08/10/虚拟化资源复用/</id>
    <published>2019-08-10T15:34:00.000Z</published>
    <updated>2019-08-15T14:46:19.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-虚拟机资源Qos"><a href="#一-虚拟机资源Qos" class="headerlink" title="一.虚拟机资源Qos"></a>一.虚拟机资源Qos</h2><p>虚拟化资源Qos在云计算场景中有着很重要的作用，可以支持虚拟机的弹性负载，提高硬件复用率，减少资源浪费， 降低企业成本等。虚拟机的资源Qos包括CPU，memory，IO，网络几个方面</p><h2 id="二-CPU-Qos"><a href="#二-CPU-Qos" class="headerlink" title="二.CPU Qos"></a>二.CPU Qos</h2><p>CPU Qos控制包括<strong>CPU 热插拔</strong>、<strong>CPU 份额</strong>、<strong>CPU 配额</strong>。</p><h3 id="1-CPU-热插拔"><a href="#1-CPU-热插拔" class="headerlink" title="1.CPU 热插拔"></a>1.CPU 热插拔</h3><p>cpu热插拔可以帮助虚拟机在高负载的情况下，不用停机直接通过热插拔cpu的方式为虚拟机进行弹性扩展，保证虚拟机里的业务稳定，虚拟化场景中配置cpu支持热插拔的xml格式如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">'static'</span> <span class="attr">current</span>=<span class="string">'3'</span>&gt;</span>6<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vcpus</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">id</span>=<span class="string">'0'</span> <span class="attr">enabled</span>=<span class="string">'yes'</span> <span class="attr">hotpluggable</span>=<span class="string">'no'</span> <span class="attr">order</span>=<span class="string">'1'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">id</span>=<span class="string">'1'</span> <span class="attr">enabled</span>=<span class="string">'no'</span> <span class="attr">hotpluggable</span>=<span class="string">'yes'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">id</span>=<span class="string">'2'</span> <span class="attr">enabled</span>=<span class="string">'no'</span> <span class="attr">hotpluggable</span>=<span class="string">'yes'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">id</span>=<span class="string">'3'</span> <span class="attr">enabled</span>=<span class="string">'no'</span> <span class="attr">hotpluggable</span>=<span class="string">'yes'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">id</span>=<span class="string">'4'</span> <span class="attr">enabled</span>=<span class="string">'yes'</span> <span class="attr">hotpluggable</span>=<span class="string">'yes'</span> <span class="attr">order</span>=<span class="string">'2'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">id</span>=<span class="string">'5'</span> <span class="attr">enabled</span>=<span class="string">'yes'</span> <span class="attr">hotpluggable</span>=<span class="string">'yes'</span> <span class="attr">order</span>=<span class="string">'3'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vcpus</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>vcpu</strong>元素中的<strong>current</strong>属性表示当前可以使用cpu的数量，6则表示支持的最大的cpu数量;<br><strong>vcpus</strong>元素中则是详细描述了每个cpu的控制状态:<strong>id</strong>值代表每个vcpu的id，这个值会在libvirt中被用作vcpu pining、调度信息以及numa分配，在某些情况下这个值可能和虚拟机看到的id不同，默认vcpu id从0开始;<strong>enabled</strong>表示在虚拟机启动的时候哪些cpu为随机启动，vcpu 0默认enabled=’yes’(虚拟机启动至少要有一个vcpu);<strong>hotpluggable</strong>表示当前vcpu是否允许热插拔，vcpu 0默认不支持热插拔; order代表vcpu在虚拟机中online的顺序(hypervisor可能会在某些操作中为了确保有效的配置而会清楚或更新order),其中vcpu的启动必须在vcpu0之后。<br>另外不是所有的hypervisor都支持cpu热插拔，还有的像PPC64这种平台的cpu热插，如果vcpu都在一个core上，则必须都需要enabled</p><h3 id="2-CPU份额"><a href="#2-CPU份额" class="headerlink" title="2.CPU份额"></a>2.CPU份额</h3><p>CPU份额表示进程在调度器中所占的权重，在虚拟化场景中，当CPU资源紧张时，可以为不同类型的虚拟机配置不同的CPU份额，例如，为一些承载关键业务的虚拟机配置高份额，保证其CPU资源的稳定。CPU配额libvirt中配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cputune</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">shares</span>&gt;</span>2048<span class="tag">&lt;/<span class="name">shares</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cputune</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在linux内核中，默认所使用的进程调度器为cfs，cfs调度器会根据cgroup的cpu子系统下的每个cgroup子组的cpu.shares计算进程的weight值，cpu.shares的值是一个相对值，cfs是根据比例计算，默认所有进程的权重值是一样的(默认值1024)，即所有进程的权重比例为1:1:1…，kvm中，libvirtd进程启动后会在cpu子系统中建立一个名为machine.slice的文件夹(即代表一个子组)，之后在创建虚拟机的时候会在machine.slice下为虚拟机创建一个machine-qemu开头的文件夹，然后在这个文件夹下会为每个vcpu创建一个文件夹(会将每个vcpu线程加入对应的文件夹下的task)，同时还会创建一个emulator文件夹(将qemu中除了vcpu线程的其他线程加入到这个文件夹下的task中)，另外libvirt在创建虚拟机的时候支持为不同的虚拟机配置不同的cpu share值，这就决定了cfs在调度的时候通过获取每个虚拟机子组中cpu.shares值计算虚拟机的调度优先级，上面xml中的shares值会写进为虚拟机创建machine-qemu开头文件夹下的cpu.shares里，vcpu与emulator的cpu.shares都是默认值1024，即qemu中所有线程的调度权重相等，但不同的qemu进程会由于shares值不同，导致在调度器的权重不同。</p><h3 id="3-CPU配额"><a href="#3-CPU配额" class="headerlink" title="3.CPU配额"></a>3.CPU配额</h3><p>CPU配额表示限制cpu使用率，通过为不同的虚拟机配置不同的配额，可以防止虚拟机资源消耗过多，同时也可以间接保证一些关键虚拟机的CPU资源。在libvirt中支持三中配置: vcpu配置配额，为整个虚拟机配置配额(即为整个qemu进程配置配额)，为io线程配置配额，CPU配额在libvirt中配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cputune</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">period</span>&gt;</span>1000000<span class="tag">&lt;/<span class="name">period</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">quota</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">quota</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">global_period</span>&gt;</span>1000000<span class="tag">&lt;/<span class="name">global_period</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">global_quota</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">global_quota</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iothread_period</span>&gt;</span>1000000<span class="tag">&lt;/<span class="name">iothread_period</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iothread_quota</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">iothread_quota</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">emulator_period</span>&gt;</span>1000000<span class="tag">&lt;/<span class="name">emulator_period</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">emulator_quota</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">emulator_quota</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cputune</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在cgroup的cpu子系统下面有cpu.cfs_period_us和cpu.cfs_quota_us两个文件两个文件,cpu.cfs_period_us代表cpu分配的周期(微秒），默认为100000。cpu.cfs_quota_us表示该control group限制占用的时间（微秒），默认为-1，表示不限制。如果设为50000，表示占用50000/10000=50%的CPU。上述配置中的period/quota代表的是配置vcpu的配额，global_period/global_quota代表的是配置qemu整个进程(包括所有子线程)的配额，iothread_period/iothread_quota代表的是配置io线程的配额，libvirt支持配置iothread，iothread的作用是增加qemu中设备io的处理能力，emulator_period/emulator_quota代表的是qemu线程中除了vcpu线程外的其他线程的配额</p><h2 id="三-内存Qos"><a href="#三-内存Qos" class="headerlink" title="三.内存Qos"></a>三.内存Qos</h2><p>内存Qos包括<strong>内存热插拔</strong>、<strong>内存balloon</strong>、<strong>内存控制</strong></p><h3 id="1-内存热插拔"><a href="#1-内存热插拔" class="headerlink" title="1.内存热插拔"></a>1.内存热插拔</h3><p>内存热插拔和CPU热插拔类似，都是在虚拟机处于高内存负载的时候，通过热插拔内存，为虚拟机提供动态扩展，保证虚拟机的高可用。libvirt中内存热插拔的配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">maxMemory</span> <span class="attr">slots</span>=<span class="string">'16'</span> <span class="attr">unit</span>=<span class="string">'KiB'</span>&gt;</span>16777216表示支持的最大内存，memory表示当前可用内存，热插内存的时候需要主要slots<span class="tag">&lt;/<span class="name">maxMemory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">'KiB'</span>&gt;</span>1048576<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br></pre></td></tr></table></figure><p>maxMemory中的slots表示有16个内存插槽，16777216表示支持的最大内存，memory表示当前可用内存，热插内存的时候需要主要slots与最大内存两个条件都必须满足才能进行热插，如果热插了15根512M的内存，再热插一个1G的内存，虽然最大内存的上限仍未达到，但是插槽已经满了，仍然不能热插内存了</p><h3 id="2-内存balloon"><a href="#2-内存balloon" class="headerlink" title="2.内存balloon"></a>2.内存balloon</h3><p>内存balloon是通过给虚拟机增加一个virtio-balloon的设备，同时在虚拟机内安装virtio-balloon驱动，使用可以根据虚拟机配置动态的调账虚拟机可用内存，内存balloon在libvirt配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">'KiB'</span>&gt;</span>4194304<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">currentMemory</span> <span class="attr">unit</span>=<span class="string">'KiB'</span>&gt;</span>1048576<span class="tag">&lt;/<span class="name">currentMemory</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当currentMemory小于memory时，qemut通过virtio-balloon设备将memory-currentMemory的差值发送给虚拟机中virtio-balloon驱动，virtio-balloon会根据差值做出相应的inflate或deflate操作(即释放或申请内存)</p><h3 id="3-内存控制"><a href="#3-内存控制" class="headerlink" title="3.内存控制"></a>3.内存控制</h3><p>内存控制是利用cgroup的memory子系统的能力达到限制虚拟机的内存使用，memory子系统下同样也是针对每个虚拟机有一个相应的machine-qemu开头的子组，通过更改虚拟机对应子组下面的soft_limit_in_bytes、limit_in_bytes、memsw.limit_in_bytes等参数，可以控制虚拟机的内存使用限制，libvirt中内存控制的配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">memtune</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hard_limit</span> <span class="attr">unit</span>=<span class="string">'KiB'</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">hard_limit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soft_limit</span> <span class="attr">unit</span>=<span class="string">'bytes'</span>&gt;</span>1048576<span class="tag">&lt;/<span class="name">soft_limit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swap_hard_limit</span> <span class="attr">unit</span>=<span class="string">'KB'</span>&gt;</span>4194304<span class="tag">&lt;/<span class="name">swap_hard_limit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">memtune</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hard_limit表示虚拟机可以使用的物理内存的上限，因此hard_limit的值会写入到memory子系统的limit_in_bytes文件;<br>soft_limit表示当系统内存不足时，通过判断虚拟机的内存是否超过soft_limit确定是否需要回收虚拟机的内存，soft_limit的值会写入到soft_limit_in_bytes文件;<br>swap_hard_limit表示虚拟机可以使用包括物理内存和交换内存的总和的大小，swap_hard_limit的值会写入到memsw.limit_in_bytes文件，另外需要注意的是hard_limit必须小于等于swap_hard_limit，否则swap_hard_limit无法写入memsw.limit_in_bytes</p><h2 id="四-磁盘IO-Qos"><a href="#四-磁盘IO-Qos" class="headerlink" title="四.磁盘IO Qos"></a>四.磁盘IO Qos</h2><p>磁盘IO是通过Cgroup实现控制虚拟机的IO读写，对磁盘IO的控制可以帮忙降低虚拟机并发启动时的IO风暴以及定位一些异常高IO的虚拟机。磁盘IO在libvirt中的配置有两种:</p><ul><li><p>第一种是blkiotune的配置，如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blkiotune</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">weight</span>&gt;</span>800<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">device</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/dev/sda<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">weight</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">device</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">device</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/dev/sdb<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">weight</span>&gt;</span>500<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">read_bytes_sec</span>&gt;</span>10000<span class="tag">&lt;/<span class="name">read_bytes_sec</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">write_bytes_sec</span>&gt;</span>10000<span class="tag">&lt;/<span class="name">write_bytes_sec</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">read_iops_sec</span>&gt;</span>20000<span class="tag">&lt;/<span class="name">read_iops_sec</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">write_iops_sec</span>&gt;</span>20000<span class="tag">&lt;/<span class="name">write_iops_sec</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">device</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blkiotune</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二种是iotune的配置，如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">'file'</span> <span class="attr">snapshot</span>=<span class="string">'external'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">"tap"</span> <span class="attr">type</span>=<span class="string">"aio"</span> <span class="attr">cache</span>=<span class="string">"default"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">'/var/lib/xen/images/fv0'</span> <span class="attr">startupPolicy</span>=<span class="string">'optional'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">seclabel</span> <span class="attr">relabel</span>=<span class="string">'no'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">'hda'</span> <span class="attr">bus</span>=<span class="string">'ide'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iotune</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">total_bytes_sec</span>&gt;</span>10000000<span class="tag">&lt;/<span class="name">total_bytes_sec</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">read_iops_sec</span>&gt;</span>400000<span class="tag">&lt;/<span class="name">read_iops_sec</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">write_iops_sec</span>&gt;</span>100000<span class="tag">&lt;/<span class="name">write_iops_sec</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iotune</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>iotune是针对每个虚拟机的磁盘块设备限制io读写，iotune是基于qemu中块设备的io流控实现的，libvirt通过调用block_set_io_throttle命令通知qemu需要设置Qos的设备以及参数。上述配置中的total_bytes_sec表示每秒允许的最大字节数;read_iops_sec表示每秒允许的读iops量;write_iops_sec表示每秒允许的写iops量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-虚拟机资源Qos&quot;&gt;&lt;a href=&quot;#一-虚拟机资源Qos&quot; class=&quot;headerlink&quot; title=&quot;一.虚拟机资源Qos&quot;&gt;&lt;/a&gt;一.虚拟机资源Qos&lt;/h2&gt;&lt;p&gt;虚拟化资源Qos在云计算场景中有着很重要的作用，可以支持虚拟机的弹性负载，提
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://huazq.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="libvirt" scheme="https://huazq.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>eventfd分析</title>
    <link href="https://huazq.github.io/2019/08/08/eventfd%E5%88%86%E6%9E%90/"/>
    <id>https://huazq.github.io/2019/08/08/eventfd分析/</id>
    <published>2019-08-08T01:57:00.000Z</published>
    <updated>2019-08-08T03:23:17.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-什么是eventfd"><a href="#一、-什么是eventfd" class="headerlink" title="一、 什么是eventfd"></a>一、 什么是eventfd</h2><p>eventfd是一种linux上的线程通信方式，和信号量等其他线程通信不同的是eventfd可以用于进程间的通信，还可以用于内核发信号给用户态的进程，eventfd是linux上的系统调用，本质上是用于事件通知。</p><h2 id="二、-eventfd特点"><a href="#二、-eventfd特点" class="headerlink" title="二、 eventfd特点"></a>二、 eventfd特点</h2><p>eventfd被设计为一个简单轻量级的文件描述符，支持在用户态作为事件进行wait和dispatch和在内核中作为事件进行dispatch，并且eventfd还可以在所有仅仅需要事件通知场景中替换pipe，并且eventfd相比于pipe在内核中开销更低，不需要消耗两个fd,当在kernel中，可以提供对fd-bridge的启用，类似 KAIO or syslets/threadlets这些功能一样通知一个fd完成某些操作，eventfd还支持epoll/poll/select的方式进行事件通知</p><h2 id="三、-eventfd原理分析"><a href="#三、-eventfd原理分析" class="headerlink" title="三、 eventfd原理分析"></a>三、 eventfd原理分析</h2><p>用户态进程通过eventfd()创建一个内核对象，这个内核对象包含一个由内核保持的无符号64位整型计数器。这个计数器由参数initval说明的值来初始化。用户态进程可以通过write/read去读写这个eventfd()返回的文件描述符，然后使用poll或select检测文件描述符的变化，继而达到事件的通知/响应机制。</p><h3 id="1-int-eventfd-unsigned-int-initval-int-flags"><a href="#1-int-eventfd-unsigned-int-initval-int-flags" class="headerlink" title="1. int eventfd(unsigned int initval, int flags);"></a>1. int eventfd(unsigned int initval, int flags);</h3><p>这个API的作用是用于产生一个文件描述符(致敬:Linux下一切皆文件)，可以对这个文件描述符进行read、write、poll、select等操作，接下来看下这个api的内核实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(eventfd2, <span class="keyword">unsigned</span> <span class="keyword">int</span>, count, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    error = get_unused_fd_flags(flags &amp; EFD_SHARED_FCNTL_FLAGS);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    fd = error;</span><br><span class="line"></span><br><span class="line">    file = eventfd_file_create(count, flags);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        error = PTR_ERR(file);</span><br><span class="line">        <span class="keyword">goto</span> err_put_unused_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_install(fd, file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">err_put_unused_fd:</span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(eventfd, <span class="keyword">unsigned</span> <span class="keyword">int</span>, count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> sys_eventfd2(count, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到代码本身就是创建一个文件描述符，这里说明下eventfd_file_create这个API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct file *<span class="title">eventfd_file_create</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventfd_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the EFD_* constants for consistency.  */</span></span><br><span class="line">BUILD_BUG_ON(EFD_CLOEXEC != O_CLOEXEC);</span><br><span class="line">BUILD_BUG_ON(EFD_NONBLOCK != O_NONBLOCK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~EFD_FLAGS_SET)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">ctx = kmalloc(<span class="keyword">sizeof</span>(*ctx), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!ctx)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">kref_init(&amp;ctx-&gt;kref);</span><br><span class="line">init_waitqueue_head(&amp;ctx-&gt;wqh);</span><br><span class="line">ctx-&gt;count = count;</span><br><span class="line">ctx-&gt;flags = flags;</span><br><span class="line"></span><br><span class="line">file = anon_inode_getfile(<span class="string">"[eventfd]"</span>, &amp;eventfd_fops, ctx,</span><br><span class="line">  O_RDWR | (flags &amp; EFD_SHARED_FCNTL_FLAGS));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">eventfd_free_ctx(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了eventfd_ctx结构，这个结构就是用来存储可以被read/write的计数器count以及后面会用到的flags，同时ctx里还有个wqh变量，这个就是等待队列，等待队列的作用就是当进程需要阻塞的时候挂在对应evnetfd的等待队列，然后调用anon_inode_getfile创建一个file结构(anon_inode_getfile的实现这里暂不多讲)，同时把eventfd_ctx作为file结构的private_data，同时关联eventfd自身的文件操作结构体eventfd_fops。</p><h3 id="2-static-ssize-t-eventfd-read-struct-file-file-char-user-buf-size-t-count-loff-t-ppos"><a href="#2-static-ssize-t-eventfd-read-struct-file-file-char-user-buf-size-t-count-loff-t-ppos" class="headerlink" title="2. static ssize_t eventfd_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)"></a>2. static ssize_t eventfd_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)</h3><p>这个API用于读取count值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">eventfd_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventfd_ctx</span> *<span class="title">ctx</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">ssize_t</span> res;</span><br><span class="line">__u64 cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &lt; <span class="keyword">sizeof</span>(cnt))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">res = eventfd_ctx_read(ctx, file-&gt;f_flags &amp; O_NONBLOCK, &amp;cnt);</span><br><span class="line"><span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> put_user(cnt, (__u64 __user *) buf) ? -EFAULT : <span class="keyword">sizeof</span>(cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> eventfd_ctx_read(struct eventfd_ctx *ctx, <span class="keyword">int</span> no_wait, __u64 *cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> res;</span><br><span class="line">DECLARE_WAITQUEUE(wait, current);</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;ctx-&gt;wqh.lock);</span><br><span class="line">*cnt = <span class="number">0</span>;</span><br><span class="line">res = -EAGAIN;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!no_wait) &#123;</span><br><span class="line">__add_wait_queue(&amp;ctx-&gt;wqh, &amp;wait);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">res = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irq(&amp;ctx-&gt;wqh.lock);</span><br><span class="line">schedule();</span><br><span class="line">spin_lock_irq(&amp;ctx-&gt;wqh.lock);</span><br><span class="line">&#125;</span><br><span class="line">__remove_wait_queue(&amp;ctx-&gt;wqh, &amp;wait);</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (likely(res == <span class="number">0</span>)) &#123;</span><br><span class="line">eventfd_ctx_do_read(ctx, cnt);</span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ctx-&gt;wqh))</span><br><span class="line">wake_up_locked_poll(&amp;ctx-&gt;wqh, POLLOUT);</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irq(&amp;ctx-&gt;wqh.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eventfd_ctx_do_read</span><span class="params">(struct eventfd_ctx *ctx, __u64 *cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*cnt = (ctx-&gt;flags &amp; EFD_SEMAPHORE) ? <span class="number">1</span> : ctx-&gt;count;</span><br><span class="line">ctx-&gt;count -= *cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在eventfd_read里先判断请求buf的size是否满足条件，这里count是64位即8个字节，所以最小读取8个字节。然后调用eventfd_ctx_read获取eventfd_ctx中的count计数，并清零，如果读取有问题则返回，否则把值写入到用户空间。</p><p>这里着重说一下eventfd_ctx_read:首先调用DECLARE_WAITQUEUE(wait, current)初始化一个wait_queue_t对象wait，之后对eventfd_ctx加锁(由于可能存在并发读取)。往下走会判断count是否大于0，如果大于0则res=0，否则返回res(默认值为-EAGAIN)，接下来看看传递进来的参数标志，如果设置了O_NONBLOCK，则就不需要等待，直接返回res(这里返回的res是小于0的情况)。如果没有指定O_NONBLOCK标志，此时由于读取不到count值（count值为0），就阻塞。然后调用__add_wait_queue把把自己加入到等待队列中，该队列会在进程等待的条件满足时唤醒它。加入到队列后进入一个死循环，设置当前进程状态为TASK_INTERRUPTIBLE，并不断检查count值，如果count大于0了，意味着有信号了，就设置res=0,然后break，然后把进程从等待队列去掉，然后设置状态TASK_RUNNING。如果count值为0，则检查是否有挂起的信号，如果有信号，同样需要先对信号进行处理,不过这次读应该就是返回失败了。之后调用调度器进行调度。如果发生了write的动作，count值会大于0，这是就会置res=0并break出去，然后会对count值进行读取。具体读取通过eventfd_ctx_do_read函数，该函数很简单， 先判断有没有指定EFD_SEMAPHORE标志，如果指定了则一次只返回1,，没有就返回count值。然后对count做减法，如果没有指定EFD_SEMAPHORE标志，实际上减去之后就为0了，有的话就减去1。之前如果有在该eventfd上阻塞的write进程，现在就可以唤醒了，所以这里检查了下，如果等待队列还有进程，则调用wake_up_locked_poll对对应的进程进行唤醒。</p><h3 id="3-static-ssize-t-eventfd-write-struct-file-file-const-char-user-buf-size-t-count-loff-t-ppos"><a href="#3-static-ssize-t-eventfd-write-struct-file-file-const-char-user-buf-size-t-count-loff-t-ppos" class="headerlink" title="3.static ssize_t eventfd_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)"></a>3.static ssize_t eventfd_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">eventfd_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventfd_ctx</span> *<span class="title">ctx</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">ssize_t</span> res;</span><br><span class="line">__u64 ucnt;</span><br><span class="line">DECLARE_WAITQUEUE(wait, current);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &lt; <span class="keyword">sizeof</span>(ucnt))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;ucnt, buf, <span class="keyword">sizeof</span>(ucnt)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (ucnt == ULLONG_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">spin_lock_irq(&amp;ctx-&gt;wqh.lock);</span><br><span class="line">res = -EAGAIN;</span><br><span class="line"><span class="keyword">if</span> (ULLONG_MAX - ctx-&gt;count &gt; ucnt)</span><br><span class="line">res = <span class="keyword">sizeof</span>(ucnt);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">__add_wait_queue(&amp;ctx-&gt;wqh, &amp;wait);</span><br><span class="line"><span class="keyword">for</span> (res = <span class="number">0</span>;;) &#123;</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (ULLONG_MAX - ctx-&gt;count &gt; ucnt) &#123;</span><br><span class="line">res = <span class="keyword">sizeof</span>(ucnt);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">res = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irq(&amp;ctx-&gt;wqh.lock);</span><br><span class="line">schedule();</span><br><span class="line">spin_lock_irq(&amp;ctx-&gt;wqh.lock);</span><br><span class="line">&#125;</span><br><span class="line">__remove_wait_queue(&amp;ctx-&gt;wqh, &amp;wait);</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (likely(res &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">ctx-&gt;count += ucnt;</span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ctx-&gt;wqh))</span><br><span class="line">wake_up_locked_poll(&amp;ctx-&gt;wqh, POLLIN);</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irq(&amp;ctx-&gt;wqh.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个API和上面的eventfd_ctx_read大致类型，先创建wait,然后判断count是不是小于8位 ，之后copy用户态传过来的值到ucnt，并判断ucnt是否等于ULLONG_MAX, 初始化res为-EAGAIN，再往下判断ucnt+ctx-&gt;count是否小于ULLONG_MAX，小于的话设置res=sizeof(ucnt)，并且把ucnt加到ctx-&gt;count上，然后唤醒read进程，并返回，如果ULLONG_MAX小于ucnt+ctx-&gt;count，则加入等待队列，设置当前进程状态为TASK_INTERRUPTIBLE，并不断检查ucnt+ctx-&gt;count是否小于ULLONG_MAX，如果ucnt+ctx-&gt;count小于ULLONG_MAX(即eventfd_read被调用了)，则设置res=sizeof(ucnt)并break出去，并且把ucnt加到ctx-&gt;count上，然后唤醒等待队列的进程，如果等待期间有信号进来，同样需要先对信号进行处理。</p><h3 id="4-u64-eventfd-signal-struct-eventfd-ctx-ctx-u64-n"><a href="#4-u64-eventfd-signal-struct-eventfd-ctx-ctx-u64-n" class="headerlink" title="4.__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)"></a>4.__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">u64 <span class="title">eventfd_signal</span><span class="params">(struct eventfd_ctx *ctx, __u64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;ctx-&gt;wqh.lock, flags);</span><br><span class="line"><span class="keyword">if</span> (ULLONG_MAX - ctx-&gt;count &lt; n)</span><br><span class="line">n = ULLONG_MAX - ctx-&gt;count;</span><br><span class="line">ctx-&gt;count += n;</span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ctx-&gt;wqh))</span><br><span class="line">wake_up_locked_poll(&amp;ctx-&gt;wqh, POLLIN);</span><br><span class="line">spin_unlock_irqrestore(&amp;ctx-&gt;wqh.lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该函数一般在内核中经常用到(例如vhost),用户内核通知用户态，和eventf_write函数类似，只不过没有阻塞，这里有点不同的是如果传进来的n+ctx-&gt;count大于ULLONG_MAX，则置n=ULLONG_MAX-ctx-&gt;count，之后设置ctx-&gt;count+=n，之后就是唤醒等待队列的进程了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、-什么是eventfd&quot;&gt;&lt;a href=&quot;#一、-什么是eventfd&quot; class=&quot;headerlink&quot; title=&quot;一、 什么是eventfd&quot;&gt;&lt;/a&gt;一、 什么是eventfd&lt;/h2&gt;&lt;p&gt;eventfd是一种linux上的线程通信方式，和信
      
    
    </summary>
    
      <category term="内核" scheme="https://huazq.github.io/categories/%E5%86%85%E6%A0%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>tmpfs介绍</title>
    <link href="https://huazq.github.io/2019/08/07/tmpfs%E4%BB%8B%E7%BB%8D/"/>
    <id>https://huazq.github.io/2019/08/07/tmpfs介绍/</id>
    <published>2019-08-07T10:46:00.000Z</published>
    <updated>2019-08-14T14:54:09.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-什么是tmpfs"><a href="#一、-什么是tmpfs" class="headerlink" title="一、 什么是tmpfs"></a>一、 什么是tmpfs</h1><p>tmpfs是一种基于内存的文件系统，和ramdisk比较类似，但不同的是，ramdisk只能使用RAM，但tmpfs也可以使用swap分区来存储。而且ramdisk创建后是个块设备，需要用mkfs指定文件系统格式化这个块设备，才能使用它；而tmpfs仅仅是一个文件系统，并不是块设备，直接使用mount命令就可以挂盘这个文件系统了。tmpfs是一个不错的基于RAM的文件系统。</p><h1 id="二、-tmpfs优劣"><a href="#二、-tmpfs优劣" class="headerlink" title="二、 tmpfs优劣"></a>二、 tmpfs优劣</h1><ul><li><p>由于内存使用采用的是POD机制，所以在使用tmpfs时也是动态增长</p></li><li><p>因为是基于内存读写的，所以速度特别快</p></li><li><p>内存是一个非持久化存储，断电后，tmpfs数据都会丢失</p></li></ul><h1 id="三、-如何使用tmpfs"><a href="#三、-如何使用tmpfs" class="headerlink" title="三、 如何使用tmpfs"></a>三、 如何使用tmpfs</h1><p>如果要启用tmpfs，需要在内核配置时，启用“Virtual memory file system support”</p><h2 id="1-直接mount，tmpfs并不是基于块设备的-，所以一个简单的-mount-命令就可以创建-tmpfs-文件系统了-在这里我们创建了一个目录，并挂载tmpfs到这个目录"><a href="#1-直接mount，tmpfs并不是基于块设备的-，所以一个简单的-mount-命令就可以创建-tmpfs-文件系统了-在这里我们创建了一个目录，并挂载tmpfs到这个目录" class="headerlink" title="1.直接mount，tmpfs并不是基于块设备的 ，所以一个简单的 mount 命令就可以创建 tmpfs 文件系统了,在这里我们创建了一个目录，并挂载tmpfs到这个目录**"></a>1.直接mount，tmpfs并不是基于块设备的 ，所以一个简单的 mount 命令就可以创建 tmpfs 文件系统了,在这里我们创建了一个目录，并挂载tmpfs到这个目录**</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/tmpfs</span><br><span class="line">mount tmpfs /mnt/tmpfs -t tmpfs</span><br></pre></td></tr></table></figure><h2 id="2-使用-dev-shm-，-dev-shm-是linux下一个非常有用的目录，这个目录就是基于tmpfs的，所以这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。默认系统就会加载-dev-shm-需要注意的是Linux默认-CentOS-dev-shm分区的大小是系统物理内存的50-。"><a href="#2-使用-dev-shm-，-dev-shm-是linux下一个非常有用的目录，这个目录就是基于tmpfs的，所以这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用-dev-shm-就可达到很好的优化效果。默认系统就会加载-dev-shm-需要注意的是Linux默认-CentOS-dev-shm分区的大小是系统物理内存的50-。" class="headerlink" title="2. 使用/dev/shm ，/dev/shm/是linux下一个非常有用的目录，这个目录就是基于tmpfs的，所以这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。默认系统就会加载/dev/shm(需要注意的是Linux默认(CentOS)/dev/shm分区的大小是系统物理内存的50%)。"></a>2. 使用/dev/shm ，/dev/shm/是linux下一个非常有用的目录，这个目录就是基于tmpfs的，所以这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。默认系统就会加载/dev/shm(需要注意的是Linux默认(CentOS)/dev/shm分区的大小是系统物理内存的50%)。</h2><p>首先为了防止tmpfs使用全部内存，在这里我们使用mount命令限制/dev/shm的大小为1G，以及提高inode数量(默认的inode数量很低一般都要调高些) 命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o size=1G -o nr_inodes=1000000  -o remount /dev/shm</span><br></pre></td></tr></table></figure><p>然后我们在/dev/shm下建个test文件夹，然后bind到/tmp，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dev/shm/test</span><br><span class="line">chmod 1777 /dev/shm/test</span><br><span class="line">mount –bind /dev/shm/test /tmp（–bind ）</span><br></pre></td></tr></table></figure><p>在使用mount –bind olderdir newerdir命令来挂载一个目录到另一个目录后，newerdir的权限和所有者等所有信息会发生变化。挂载后的目录继承了被挂载目录的所有属性</p><p>更改fstab，使/dev/shm在系统启动时默认挂载的大小为1G</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@huazq ~]# vi /etc/fstab</span><br><span class="line">tmpfs                   /dev/shm                tmpfs   defaults,size=1G        0 0</span><br><span class="line">sysfs                   /sys                    sysfs   defaults                       0 0</span><br><span class="line">proc                    /proc                   proc    defaults                       0 0</span><br><span class="line">/dev/sda1               swap                    swap    defaults                      0 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、-什么是tmpfs&quot;&gt;&lt;a href=&quot;#一、-什么是tmpfs&quot; class=&quot;headerlink&quot; title=&quot;一、 什么是tmpfs&quot;&gt;&lt;/a&gt;一、 什么是tmpfs&lt;/h1&gt;&lt;p&gt;tmpfs是一种基于内存的文件系统，和ramdisk比较类似，但不同
      
    
    </summary>
    
      <category term="文件系统" scheme="https://huazq.github.io/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="https://huazq.github.io/2019/08/07/Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://huazq.github.io/2019/08/07/Markdown语法/</id>
    <published>2019-08-07T09:08:00.000Z</published>
    <updated>2019-08-12T02:05:41.824Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Markdown是一种轻量级的「标记语言」</strong></p><p><img src="https://www.mdeditor.com/images/logos/markdown.png" alt="markdown" title="markdown"></p><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p><h2 id="MdEditor是一个在线编辑Markdown文档的编辑器"><a href="#MdEditor是一个在线编辑Markdown文档的编辑器" class="headerlink" title="MdEditor是一个在线编辑Markdown文档的编辑器"></a>MdEditor是一个在线编辑Markdown文档的编辑器</h2><p><em>MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。</em></p><blockquote><p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<del>Pandoc</del>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p></blockquote><p>MdEditor源于Pandao的JavaScript开源项目，开源地址<a href="https://github.com/pandao/editor.md" title="Editor.md" target="_blank" rel="noopener">Editor.md</a>，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。</p><p><img src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png" alt="Pandao editor.md" title="Pandao editor.md"></p><h2 id="MdEditor的功能列表演示"><a href="#MdEditor的功能列表演示" class="headerlink" title="MdEditor的功能列表演示"></a>MdEditor的功能列表演示</h2><h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H5-1"><a href="#标题H5-1" class="headerlink" title="标题H5"></a>标题H5</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr><p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p><p><em>斜体字</em>      <em>斜体字</em></p><p><strong>粗体</strong>  <strong>粗体</strong></p><p><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p><p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p><p><strong>缩写(同HTML的abbr标签)</strong></p><blockquote><p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p></blockquote><p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p><h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote><p>引用文本 Blockquotes</p></blockquote><p>引用的行内混合 Blockquotes</p><blockquote><p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a>。</p></blockquote><h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a><br><a href="https://www.mdeditor.com/" title="普通链接带标题" target="_blank" rel="noopener">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com" target="_blank" rel="noopener">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/" target="_blank" rel="noopener">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com" target="_blank" rel="noopener">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:test.test@gmail.com" target="_blank" rel="noopener">test.test@gmail.com</a>  <a href="mailto:www@vip.qq.com" target="_blank" rel="noopener">www@vip.qq.com</a></p><blockquote><p>@pandao</p></blockquote><h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p><h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p><pre><code>&lt;?php    echo &quot;Hello world!&quot;;?&gt;</code></pre><p>预格式化文本：</p><pre><code>| First Header  | Second Header || ------------- | ------------- || Content Cell  | Content Cell  || Content Cell  | Content Cell  |</code></pre><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Editor.md, Markdown, Editor"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">            body&#123;font-size:14px;color:#444;font-family: "Microsoft Yahei", Tahoma, "Hiragino Sans GB", Arial;background:#fff;&#125;</span><br><span class="line">            ul&#123;list-style: none;&#125;</span><br><span class="line">            img&#123;border:none;vertical-align: middle;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-xxl"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-green"</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p><p><a href="https://www.mdeditor.com/images/logos/markdown.png" title="markdown" target="_blank" rel="noopener"><img src="https://www.mdeditor.com/images/logos/markdown.png" alt></a></p><blockquote><p>Follow your heart.</p></blockquote><hr><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul><li>列表一</li><li>列表二<ul><li>列表二-1</li><li>列表二-2</li><li>列表二-3</li></ul></li><li>列表三<ul><li>列表一</li><li>列表二</li><li>列表三</li></ul></li></ul><h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol><li>第一行</li><li>第二行</li><li>第三行</li></ol><h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul><li><input checked disabled type="checkbox"> GFM task list 1</li><li><input checked disabled type="checkbox"> GFM task list 2</li><li><input disabled type="checkbox"> GFM task list 3<ul><li><input disabled type="checkbox"> GFM task list 3-1</li><li><input disabled type="checkbox"> GFM task list 3-2</li><li><input disabled type="checkbox"> GFM task list 3-3</li></ul></li><li><input disabled type="checkbox"> GFM task list 4<ul><li><input disabled type="checkbox"> GFM task list 4-1</li><li><input disabled type="checkbox"> GFM task list 4-2</li></ul></li></ul><hr><h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>Function name</th><th>Description</th></tr></thead><tbody><tr><td><code>help()</code></td><td>Display the help window.</td></tr><tr><td><code>destroy()</code></td><td><strong>Destroy your computer!</strong></td></tr></tbody></table><table><thead><tr><th align="left">Left-Aligned</th><th align="center">Center Aligned</th><th align="right">Right Aligned</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><table><thead><tr><th>Item</th><th align="right">Value</th></tr></thead><tbody><tr><td>Computer</td><td align="right">$1600</td></tr><tr><td>Phone</td><td align="right">$12</td></tr><tr><td>Pipe</td><td align="right">$1</td></tr></tbody></table><hr><h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p><p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p><p>18&ordm;C  &quot;  &apos;</p><p>[========]</p><h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote><p>Blockquotes :star:</p></blockquote><h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul><li><input checked disabled type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href>links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li><li><input checked disabled type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li><li><input checked disabled type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li><li><input disabled type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li><li><input disabled type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul><li><input disabled type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li><li><input disabled type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li></ul></li></ul><h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p><p>[========]</p><h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p><p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p><p>$$x &gt; y$$</p><p>$$(\sqrt{3x-1}+(1+x)^2)$$</p><p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p><p>多行公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = \int_&#123;-\infty&#125;^\infty</span><br><span class="line">    \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125;</span><br><span class="line">    \,d\xi</span><br></pre></td></tr></table></figure><h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote><p>Print Test: Ctrl + P</p></blockquote><p>[========]</p><h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 用户登陆</span><br><span class="line">op=&gt;operation: 登陆操作</span><br><span class="line">cond=&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e=&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>[========]</p><h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Markdown是一种轻量级的「标记语言」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mdeditor.com/images/logos/markdown.png&quot; alt=&quot;markdown&quot; title=&quot;markdow
      
    
    </summary>
    
      <category term="杂类" scheme="https://huazq.github.io/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
  </entry>
  
</feed>
